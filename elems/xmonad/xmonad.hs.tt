-- ────────────────────────────────────────────────────────────────────────────┐
--                                                                             │
-- Name:    elems/xmonad.hs.tt                                                 │
-- Summary: XMonad configuration.                                              │
-- Authors:                                                                    │
--   - Alessandro Molari <molari.alessandro@gmail.com> (alem0lars)             │
--                                                                             │
-- Project:                                                                    │
--   - Homepage:        https://github.com/alem0lars/configs-xmonad            │
--   - Getting started: see README.md in the project root folder               │
--                                                                             │
-- License: Apache v2.0 (see below)                                            │
--                                                                             │
-- ────────────────────────────────────────────────────────────────────────────┤
--                                                                             │
-- Licensed to the Apache Software Foundation (ASF) under one more contributor │
-- license agreements.  See the NOTICE file distributed with this work for     │
-- additional information regarding copyright ownership. The ASF licenses this │
-- file to you under the Apache License, Version 2.0 (the "License"); you may  │
-- not use this file except in compliance with the License.                    │
-- You may obtain a copy of the License at                                     │
--                                                                             │
--   http://www.apache.org/licenses/LICENSE-2.0                                │
--                                                                             │
-- Unless required by applicable law or agreed to in writing, software         │
-- distributed under the License is distributed on an "AS IS" BASIS, WITHOUT   │
-- WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.            │
-- See the License for the specific language governing permissions and         │
-- limitations under the License.                                              │
--                                                                             │
-- ────────────────────────────────────────────────────────────────────────────┤
<% define_locals do
  variable :web_browser

  prefixed(:"xmonad.", as: nil) do
    variable :"terminal.open_cmd", as: :term_open_cmd
    variable :"terminal.run_cmd",  as: :term_run_cmd

    variable :workspace_dir

    variable :"font.name", as: :font_name
    variable :"font.size", as: :font_size, type: :int

    variable(:colorscheme) do |colorscheme|
      Hash[colorscheme.map { |name, hex| [name.camelize, hex] }]
    end
  end
end %>
-- ────────────────────────────────────────────────────────────────────────────┘


-- ┌───────────────────────────────────────────────────────────────────────────┐
-- │                            TABLE OF CONTENTS                              │
-- ├┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┤
-- │                                                                           │
-- │ ┌──→ •1• imports                                                          │
-- │ │                                                                         │
-- │ ├──→ •2• xconfig                                                          │
-- │ │     │                                                                   │
-- │ │     ├─→ •2.01• layouts                                                  │
-- │ │     ├─→ •2.02• workspaces                                               │
-- │ │     ├─→ •2.03• log hook                                                 │
-- │ │     ├─→ •2.04• statusbar                                                │
-- │ │     ├─→ •2.05• startup hook                                             │
-- │ │     ├─→ •2.06• handle event hook                                        │
-- │ │     ├─→ •2.07• manage hook                                              │
-- │ │     ├─→ •2.08• scratchpads                                              │
-- │ │     ├─→ •2.09• key bindings                                             │
-- │ │     ├─→ •2.10• mouse bindings                                           │
-- │ │     ├─→ •2.11• misc                                                     │
-- │ │     ├─→ •2.12• prompt                                                   │
-- │ │     ├─→ •2.13• colors                                                   │
-- │ │     ├─→ •2.14• fonts                                                    │
-- │ │     └─→ •2.15• sizes                                                    │
-- │ │                                                                         │
-- │ └──→ •3• types                                                            │
-- │                                                                           │
-- └───────────────────────────────────────────────────────────────────────────┘


-- ───────────────────────────────────────────────────────────── imports •1• ──┐

import GHC.IO.Handle.Types (Handle)

import System.Exit (ExitCode(ExitSuccess), exitWith)

import Data.Bits ((.&.), bitSize, complement)

import qualified Data.List   as List
import qualified Data.Map    as Map
import qualified Data.Monoid as Monoid

import XMonad ( xmonad
              , X
              , (|||)
              , (.|.)
              , (<+>)
              , (-->)
              , (=?)
              , KeyMask, KeySym, Button                     -- keymap data types
              , xK_a, xK_b, xK_c, xK_d, xK_e, xK_f    -- alphanumeric keys (1/5)
              , xK_g, xK_h, xK_i, xK_j, xK_k, xK_l    -- alphanumeric keys (2/5)
              , xK_m, xK_n, xK_o, xK_p, xK_q, xK_r    -- alphanumeric keys (3/5)
              , xK_s, xK_t, xK_u, xK_v, xK_w, xK_x    -- alphanumeric keys (4/5)
              , xK_y, xK_z                            -- alphanumeric keys (5/5)
              , xK_1, xK_2, xK_3, xK_4, xK_5, xK_6         -- numeric keys (1/2)
              , xK_7, xK_8, xK_9, xK_0                     -- numeric keys (2/2)
              , xK_Tab, xK_Return, xK_grave, xK_comma        -- other keys (1/3)
              , xK_space, xK_period, xK_slash, xK_Alt_L      -- other keys (2/3)
              , xK_minus, xK_plus, xK_Super_L                -- other keys (3/3)
              , xK_Left, xK_Right, xK_Up, xK_Down                      -- arrows
              , mod1Mask, mod2Mask, mod3Mask, mod4Mask, mod5Mask  -- masks (1/2)
              , shiftMask, controlMask, lockMask                  -- masks (2/2)
              , button1, button2, button3                             -- buttons
              )
import qualified XMonad.Core as XMonad
import qualified XMonad      as XM

import qualified XMonad.Actions.Commands           as Commands
import qualified XMonad.Actions.ConstrainedResize  as ConstrResize
import qualified XMonad.Actions.CopyWindow         as CopyWindow -- TODO integrate with taffybar (status bar PP)
import qualified XMonad.Actions.CycleRecentWS      as CycleRecentWS
import qualified XMonad.Actions.CycleWS            as CycleWS
import qualified XMonad.Actions.CycleWindows       as CycleWindows
import qualified XMonad.Actions.DwmPromote         as Promote
import qualified XMonad.Actions.FlexibleManipulate as FlexM
import qualified XMonad.Actions.FlexibleResize     as FlexR
import qualified XMonad.Actions.FloatSnap          as FloatSnap
import qualified XMonad.Actions.FocusNth           as FocusNth
import qualified XMonad.Actions.Launcher           as Launcher
import qualified XMonad.Actions.PhysicalScreens    as PhyScreens
import qualified XMonad.Actions.RotSlaves          as RotSlaves
import qualified XMonad.Actions.Search             as Search
import qualified XMonad.Actions.Submap             as Submap
import qualified XMonad.Actions.UpdatePointer      as UpdatePointer

import qualified XMonad.Hooks.DynamicLog    as DynLog
import qualified XMonad.Hooks.EwmhDesktops  as EWMH
import qualified XMonad.Hooks.ICCCMFocus    as ICCCMFocus
import qualified XMonad.Hooks.ManageDocks   as ManageDocks
import qualified XMonad.Hooks.ManageHelpers as ManageHelpers
import qualified XMonad.Hooks.Place         as Place
import qualified XMonad.Hooks.SetWMName     as SetWMName
import qualified XMonad.Hooks.UrgencyHook   as UrgencyHook

import qualified XMonad.Layout.MultiToggle           as MultiToggle
import qualified XMonad.Layout.MultiToggle.Instances as MultiToggleI
import qualified XMonad.Layout.NoBorders             as NoBorders
import qualified XMonad.Layout.PerWorkspace          as PerWorkspace
import qualified XMonad.Layout.Reflect               as Reflect
import qualified XMonad.Layout.Tabbed                as Tabbed
import qualified XMonad.Layout.WorkspaceDir          as WorkspaceDir

import qualified XMonad.ManageHook as ManageHook

import qualified XMonad.Prompt as Prompt

import qualified XMonad.StackSet as StackSet

import qualified XMonad.Util.NamedScratchpad as Scratchpad
import qualified XMonad.Util.Run             as Run

import qualified System.Taffybar.Hooks.PagerHints as Taffybar

-- ────────────────────────────────────────────────────────────────────────────┘


-- ───────────────────────────────────────────────────────────── xconfig •2• ──┐

main :: IO ()
main  = do xmonad $ UrgencyHook.withUrgencyHook UrgencyHook.NoUrgencyHook
                  $ EWMH.ewmh
                  $ Taffybar.pagerHints
                  $ xConfig
  where
    xConfig = XM.defaultConfig
            { XMonad.layoutHook         = layoutHook
            , XMonad.manageHook         = manageHook
            , XMonad.handleEventHook    = handleEventHook
            , XMonad.startupHook        = startupHook
            , XMonad.workspaces         = workspaces
            , XMonad.modMask            = metaMask
            , XMonad.focusFollowsMouse  = shouldFocusFollowMouse
            , XMonad.clickJustFocuses   = shouldClickJustFocus
            , XMonad.borderWidth        = windowBorderWidth
            , XMonad.normalBorderColor  = toHex inactiveBorderColor
            , XMonad.focusedBorderColor = toHex activeBorderColor
            , XMonad.terminal           = terminal
            , XMonad.keys               = keymapConfig
            , XMonad.mouseBindings      = mousemapConfig
            }

    mousemapConfig = \conf@(XM.XConfig {XMonad.modMask = modMask})
                  -> Map.fromList [ (key, action)
                                  | (key, action, desc) <- mouseMaps
                                  ]

    keymapConfig = \conf@(XM.XConfig {XMonad.modMask = modMask})
                -> Map.fromList [ (key, action)
                                | (key, action, _) <- keymaps
                                ]

-- ────────────────────────────────────────────────────────── layouts •2.01• ──┤

-- type is not specified because it is fucking hell (check `:t layoutHook`)
-- luckly haskell has powerful type inference :D
layoutHook = NoBorders.smartBorders . ManageDocks.avoidStruts
           $ WorkspaceDir.workspaceDir workspaceDir
           $ MultiToggle.mkToggle1 MultiToggleI.NBFULL    -- switch to full
           $ MultiToggle.mkToggle1 Reflect.REFLECTX       -- reflect x-axis
           $ MultiToggle.mkToggle1 Reflect.REFLECTY       -- reflect y-axis
           $ MultiToggle.mkToggle1 MultiToggleI.NOBORDERS -- remove borders
           $ MultiToggle.mkToggle1 MultiToggleI.MIRROR    -- mirror layout
           $ PerWorkspace.onWorkspace (workspaces !! 0) myRefLayouts
           $ PerWorkspace.onWorkspace (workspaces !! 1) myWflowLayouts
           $ PerWorkspace.onWorkspace (workspaces !! 2) myWflowLayouts
           $ PerWorkspace.onWorkspace (workspaces !! 3) myWflowsuppLayouts
           $ PerWorkspace.onWorkspace (workspaces !! 4) myOrgLayouts
           $ PerWorkspace.onWorkspace (workspaces !! 5) mySocialLayouts
           $ PerWorkspace.onWorkspace (workspaces !! 6) myPlayLayouts
           $ PerWorkspace.onWorkspace (workspaces !! 7) myMgmtLayouts
           $ PerWorkspace.onWorkspace (workspaces !! 8) myTmpLayouts
           $ PerWorkspace.onWorkspace (workspaces !! 9) myComboLayouts
           $ myDefaultLayouts
  where
    workspaceDir = "<%= File.expand_path local!(:workspace_dir) %>"

    -- Layout groups
    tabbedLayout = Tabbed.tabbed Tabbed.shrinkText $ Tabbed.defaultTheme
                 { Tabbed.inactiveColor       = toHex inactiveBgColor
                 , Tabbed.inactiveTextColor   = toHex inactiveFgColor
                 , Tabbed.inactiveBorderColor = toHex inactiveBorderColor
                 , Tabbed.activeColor         = toHex activeBgColor
                 , Tabbed.activeTextColor     = toHex activeFgColor
                 , Tabbed.activeBorderColor   = toHex activeBorderColor
                 , Tabbed.urgentColor         = toHex urgentBgColor
                 , Tabbed.urgentTextColor     = toHex urgentFgColor
                 , Tabbed.urgentBorderColor   = toHex urgentBorderColor
                 }

    -- TODO: decide
    myRefLayouts       = tabbedLayout ||| myGridLayout
    myWflowLayouts     = myOneBigLayout ||| myMosaicLayout ||| myGridLayout ||| tabbedLayout
    myWflowsuppLayouts = tabbedLayout ||| myGridLayout ||| myOneBigLayout ||| myMosaicLayout
    myOrgLayouts       = tabbedLayout ||| myGridLayout
    mySocialLayouts    = tabbedLayout ||| myGridLayout
    myPlayLayouts      = tabbedLayout ||| myGridLayout
    myMgmtLayouts      = myGridLayout ||| myOneBigLayout ||| tabbedLayout
    myTmpLayouts       = myGridLayout ||| tabbedLayout
    myComboLayouts     = tabbedLayout
    myDefaultLayouts   = myWflowLayouts

    -- Layout definitions
    myCrossLayout     = XM.Full -- TODO simpleCross
    myFullLayout      = XM.Full -- TODO Full
    myAccordionLayout = XM.Full -- TODO Accordion
    myGridLayout      = XM.Full -- TODO Grid
    mySpiralLayout    = XM.Full -- TODO spiral (1/2)
    myMosaicLayout    = XM.Full -- TODO mosaic 2 [3, 2]
    myFloatLayout     = XM.Full -- TODO simpleFloat
    myOneBigLayout    = XM.Full -- TODO OneBig 0.6 0.74

-- ─────────────────────────────────────────────────────── workspaces •2.02• ──┤

workspaces :: [String]
workspaces  = zipWith (++) workspaceIds
            $ map (separator ++) workspaceNames
  where
    delimiter = "•"
    separator = ""

    workspaceIds = [ (show workspaceIndex)  ++ delimiter
                   | workspaceIndex <- [1..]
                   ]

    workspaceNames = [ "ref"
                     , "wf"
                     , "wf"
                     , "wfs"
                     , "org"
                     , "social"
                     , "play"
                     , "mgmt"
                     , "tmp"
                     , "combo"
                     ]

-- ───────────────────────────────────────────────────────── log hook •2.03• ──┤

-- logHook :: Handle
--         -> X ()
--
-- logHook h = do copies <- CopyWindow.wsContainingCopies
--                ICCCMFocus.takeTopFocus
--                DynLog.dynamicLogWithPP (statusPP h copies)
--                UpdatePointer.updatePointer (0.5, 0.5) (0, 0)
--
-- statusBarCmd :: String
-- statusBarCmd  = "/usr/bin/xmobar"
--
-- statusPP :: Foldable t
--          => Handle
--          -> t String
--          -> DynLog.PP
--
-- statusPP h copies = DynLog.defaultPP
--                   { DynLog.ppCurrent         = format currentColor currentSymbols
--                   , DynLog.ppVisible         = format visibleColor visibleSymbols
--                   , DynLog.ppHidden          = formatHidden copies
--                   , DynLog.ppHiddenNoWindows = format emptyColor   emptySymbols
--                   , DynLog.ppUrgent          = format urgentColor  urgentSymbols
--                   , DynLog.ppLayout          = format layoutColor  layoutSymbols
--                                              . take 16 -- maximum layout name (TODO to be computed automatically)
--                                           . (++ repeat ' ')
--                   , DynLog.ppSep    = "  "
--                   , DynLog.ppWsSep  = " "
--                   , DynLog.ppTitle  = take 0
--                   , DynLog.ppOutput = Run.hPutStrLn h
--                   }
--   where
--     formatHidden copies ws | (ws `elem` copies) = format hiddenWithCopiesColor hiddenSymbols ws
--                            | otherwise          = format hiddenColor           hiddenSymbols ws
--     -- utility function: surround with symbols and apply colors
--     format colorSpec symbolSpec = uncurry DynLog.xmobarColor (mapT toHex colorSpec)
--                                 . uncurry DynLog.wrap symbolSpec
--
--     currentColor   = (bgColor, green colors)
--     currentSymbols = (" ◄ ", " ► ")
--
--     visibleColor   = (bgColor, orange colors)
--     visibleSymbols = (" |", "| ")
--
--     hiddenWithCopiesColor = (bgColor, yellow colors)
--     hiddenColor           = (bgColor, cyan colors)
--     hiddenSymbols         = (" ⟨ ", " ⟩ ")
--
--     emptyColor   = (bgColor, grey colors)
--     emptySymbols = (" ∅ ", " ∅ ")
--
--     urgentColor   = (bgColor, red colors)
--     urgentSymbols = (" ! ", " ! ")
--
--     layoutColor   = (bgColor, magenta colors)
--     layoutSymbols = (" λ ", " λ ")

-- ───────────────────────────────────────────────────── startup hook •2.05• ──┤

startupHook :: X ()
startupHook  = do EWMH.ewmhDesktopsStartup
                  SetWMName.setWMName "LG3D"

-- ──────────────────────────────────────────────── handle event hook •2.06• ──┤

handleEventHook :: XM.Event
                -> X Monoid.All

handleEventHook =  XM.handleEventHook XM.defaultConfig
               <+> ManageDocks.docksEventHook
               <+> EWMH.ewmhDesktopsEventHook
               <+> EWMH.fullscreenEventHook

-- ────────────────────────────────────────────────────── manage hook •2.07• ──┤

manageHook ::  XM.ManageHook
manageHook  =  Place.placeHook floatingWindowPlacement
           <+> basicManageHook
           <+> XM.manageHook XM.defaultConfig

floatingWindowPlacement :: Place.Placement
floatingWindowPlacement  = Place.withGaps (16, 0, 16, 0)
                         $ Place.smart (0.5, 0.5)

basicManageHook :: XM.ManageHook
basicManageHook  = XM.composeAll . concat $
                 [ [ManageDocks.manageDocks]
                 , [Scratchpad.namedScratchpadManageHook scratchpads]
                 , [ManageHelpers.isFullscreen --> ManageHelpers.doFullFloat]
                 , [ManageHelpers.isDialog     --> ManageHook.doFloat]
                 , [ checkXWindowQuery q --> ManageHook.doFloat
                   | q <- floats
                   ]
                 , [ checkXWindowQuery q --> ManageHook.doShift w
                   | (q, w) <- shifts
                   ]
                 ]
  where
    floats = [ XWindowClass "Pavucontrol"
             , XWindowClass "copyq"
             , XWindowClass "Xmessage"
             , XWindowClass "TeamViewer.exe"
             , XWindowTitle "Save As..."
             ]

    shifts = [ (XWindowClass "Firefox",                   workspaces !! 0)
             , (XWindowClass "chromium-browser-chromium", workspaces !! 0)
             ]

-- ────────────────────────────────────────────────────── scratchpads •2.08• ──┤

scratchpadSize :: StackSet.RationalRect
scratchpadSize  = StackSet.RationalRect (1 / 4) (1 / 4) (1 / 2) (1 / 2)

scratchpads :: [Scratchpad.NamedScratchpad]
scratchpads  = [ scratchpad "term" terminal
               , scratchpad "htop" "htop"
               <% if has_feature? :python %>
               , scratchpad "ipython" "ipython"
               <% end %>
               <% if has_feature? :ruby %>
               , scratchpad "irb" "irb"
               <% end %>
               <% if has_feature? :haskell %>
               , scratchpad "ghci" "ghci"
               <% end %>
               ]
  where
    scratchpad name cmd = Scratchpad.NS name (runCmd cmd)
                                             (ManageHook.title =? name)
                                             size

    runCmd cmd = "<%= local! :term_run_cmd %> " ++ cmd

    size = Scratchpad.customFloating scratchpadSize

-- ───────────────────────────────────────────────────── key bindings •2.09• ──┤

metaMask :: KeyMask
metaMask  = mod4Mask

altMask :: KeyMask
altMask  = mod1Mask

keymaps :: [((KeyMask, KeySym), X (), String)]
keymaps  = [ -- ───────────────────────────── window management •2.09.01•    ──┤
             -- ────────────── change focus ← window management •2.09.01.01• ──┤
             ( (metaMask, xK_j)
             , XM.windows StackSet.focusDown
             , "move focus to the next window"
             )
           , ( (metaMask, xK_k)
             , XM.windows StackSet.focusUp
             , "move focus to the previous window"
             )
           , ( (metaMask, xK_Tab)
             , XM.windows StackSet.focusDown
             , "move focus to the next window"
             )
           , ( (metaMask .|. shiftMask, xK_Tab)
             , XM.windows StackSet.focusUp
             , "move focus to the previous window"
             )
           ]
           ++
           [ -- ───────────────── focus nth ← window management •2.09.01.02• ──┤
             ( (metaMask .|. altMask, key)
             , FocusNth.focusNth num
             , "focus the window nr." ++ show num ++ " of the current workspace"
             )
           | (key, num) <- zip numericKeys [0..]
           ]
           ++
           [ -- ────────────────────── swap ← window management •2.09.01.03• ──┤
             ( (metaMask, xK_Return)
             , Promote.dwmpromote
             , "swap focused window with master window"
             )
           , ( (metaMask .|. shiftMask, xK_j)
             , XM.windows StackSet.swapDown
             , "swap focused window with next window"
             )
           , ( (metaMask .|. shiftMask, xK_k)
             , XM.windows StackSet.swapUp
             , "swap focused window with previous window"
             )
           , ( (metaMask .|. altMask .|. shiftMask, xK_j)
             , RotSlaves.rotSlavesUp
             , "rotate (up) the windows in the current stack, " ++
               "excluding the master window"
             )
           , ( (metaMask .|. altMask .|. shiftMask, xK_k)
             , RotSlaves.rotSlavesDown
             , "rotate (down) the windows in the current stack, " ++
               "excluding the master window"
             )
           , ( (metaMask .|. altMask, xK_Tab)
             , CycleWindows.cycleRecentWindows [xK_Super_L] xK_s xK_w
             , "cycle recent windows"
             )
           , ( (metaMask, xK_z)
             , CycleWindows.rotOpposite
             , "opposite rotation on a stack"
             )
           , ( (metaMask, xK_Up)
             , CycleWindows.rotUnfocusedUp
             , "rotate windows up through the unfocused frames"
             )
           , ( (metaMask, xK_Down)
             , CycleWindows.rotUnfocusedDown
             , "rotate windows down through the unfocused frames"
             )
           , ( (metaMask .|. altMask, xK_Up) -- TODO key clash
             , CycleWindows.rotFocusedUp
             , "rotate windows up through the focused frames"
             )
           , ( (metaMask .|. altMask, xK_Down) -- TODO key clash
             , CycleWindows.rotFocusedDown
             , "rotate windows down through the focused frames"
             )
             -- ──────────────────── resize ← window management •2.09.01.04• ──┤
           , ( (metaMask, xK_n)
             , XM.refresh
             , "resize viewed windows to the correct size"
             )
           , ( (metaMask, xK_h)
             , XM.sendMessage XM.Shrink
             , "shrink the master area"
             )
           , ( (metaMask, xK_l)
             , XM.sendMessage XM.Expand
             , "expand the master area"
             )
             -- ────────────── master/slave ← window management •2.09.01.05• ──┤
           , ( (metaMask, xK_m)
             , XM.windows StackSet.focusMaster
             , "move focus to the master window"
             )
           , ( (metaMask .|. altMask, xK_plus)
             , XM.sendMessage (XM.IncMasterN 1)
             , "increment the number of windows in the master area"
             )
           , ( (metaMask .|. altMask, xK_minus)
             , XM.sendMessage (XM.IncMasterN (-1))
             , "deincrement the number of windows in the master area"
             )
           ]
           ++
           [ -- ───────── copy to workspace ← window management •2.09.01.06• ──┤
             ( (metaMask .|. altMask .|. shiftMask, key)
             , XM.windows $ CopyWindow.copy workspace
             , "copy focused window to workspace '" ++ workspace ++ "'" ++
               " (nr." ++ show num ++ ")"
             )
           | (workspace, key, num) <- zip3 workspaces numericKeys [1..]
           ]
           ++
           [ -- ───────── move to workspace ← window management •2.09.01.07• ──┤
             ( (metaMask .|. shiftMask, key)
             , XM.windows $ StackSet.shift workspace
             , "move focused window to workspace '" ++ workspace ++ "'" ++
               " (nr." ++ show num ++ ")"
             )
           | (workspace, key, num) <- zip3 workspaces numericKeys [1..]
           ]
           ++
           [ -- ───────────────────── float ← window management •2.09.01.08• ──┤
             ( (metaMask, xK_t)
             , XM.withFocused $ XM.windows . StackSet.sink
             , "push window back into tiling"
             )
           , ( (metaMask .|. altMask, xK_r)
             , Place.placeFocused floatingWindowPlacement
             , "manually reposition focused floating window"
             )
           , ( (metaMask .|. altMask, xK_Left)
             , XM.withFocused $ FloatSnap.snapMove FloatSnap.L Nothing
             , "snap focused window to left border"
             )
           , ( (metaMask .|. altMask, xK_Right)
             , XM.withFocused $ FloatSnap.snapMove FloatSnap.R Nothing
             , "snap focused window to right border"
             )
           , ( (metaMask .|. altMask, xK_Up)
             , XM.withFocused $ FloatSnap.snapMove FloatSnap.U Nothing
             , "snap focused window to top border"
             )
           , ( (metaMask .|. altMask, xK_Down)
             , XM.withFocused $ FloatSnap.snapMove FloatSnap.D Nothing
             , "snap focused window to bottom border"
             )
           , ( (metaMask .|. altMask .|. shiftMask, xK_Left)
             , XM.withFocused $ FloatSnap.snapShrink FloatSnap.L Nothing
             , "expand focused window filling up to the left border"
             )
           , ( (metaMask .|. altMask .|. shiftMask, xK_Right)
             , XM.withFocused $ FloatSnap.snapGrow FloatSnap.R Nothing
             , "expand focused window filling up to the right border"
             )
           , ( (metaMask .|. altMask .|. shiftMask, xK_Up)
             , XM.withFocused $ FloatSnap.snapShrink FloatSnap.U Nothing
             , "expand focused window filling up to the top border"
             )
           , ( (metaMask .|. altMask .|. shiftMask, xK_Down)
             , XM.withFocused $ FloatSnap.snapGrow FloatSnap.D Nothing
             , "expand focused window filling up to the bottom border"
             )
             -- ────────────────────────── workspace management •2.09.02•    ──┤
             -- ───────────────── switch ← workspace management •2.09.02.01• ──┤
           , ( (metaMask .|. controlMask, xK_Tab)
             , CycleRecentWS.cycleRecentWS [xK_Alt_L] xK_Tab xK_grave
             , "cycle through most recent workspaces"
             )
           , ( (metaMask .|. controlMask, xK_Down)
             , CycleWS.prevWS
             , "switch to previous workspace"
             )
           , ( (metaMask .|. controlMask, xK_Up)
             , CycleWS.nextWS
             , "switch to next workspace"
             )
           , ( (metaMask .|. controlMask, xK_z)
             , CycleWS.toggleWS
             , "toggle to the workspace displayed previously"
             )
           ]
           ++
           [ ( (metaMask, key)
             , XM.windows $ StackSet.greedyView workspace
             , "switch to workspace '" ++ workspace ++ "'" ++
               "(nr." ++ show num ++ ")"
             )
           | (workspace, key, num) <- zip3 workspaces numericKeys [1..]
           ]
           ++
           [ -- ──────────── move window ← workspace management •2.09.02.02• ──┤
             ( (metaMask .|. controlMask .|. shiftMask, xK_Down)
             , CycleWS.shiftToPrev
             , "move focused window to previous workspace"
             )
           , ( (metaMask .|. controlMask .|. shiftMask, xK_Up)
             , CycleWS.shiftToNext
             , "move focused window to next workspace"
             )
             -- ───────────────────────────── screen management •2.09.03•    ──┤
             -- ──────────────────── switch ← screen management •2.09.03.01• ──┤
           , ( (metaMask, xK_w)
             , PhyScreens.onPrevNeighbour StackSet.view
             , "switch to previous screen"
             )
           , ( (metaMask, xK_e)
             , PhyScreens.onNextNeighbour StackSet.view
             , "switch to next screen"
             )
           ]
           ++
           [ ( (metaMask .|. altMask, key)
             , PhyScreens.viewScreen screenNum
             , "switch to screen nr." ++ show screenNum
             )
           | (key, screenNum) <- zip numericKeys [0..]
           ]
           ++
           [ -- ─────────────── move window ← screen management •2.09.03.02• ──┤
             ( (metaMask .|. altMask .|. shiftMask, xK_w)
             , PhyScreens.onPrevNeighbour StackSet.shift
             , "move focused window to previous screen"
             )
           , ( (metaMask .|. altMask .|. shiftMask, xK_e)
             , PhyScreens.onNextNeighbour StackSet.shift
             , "move focused window to next screen"
             )
           ]
           ++
           [ ( (metaMask .|. altMask .|. shiftMask, key)
             , PhyScreens.sendToScreen screenNum
             , "move focused window to screen nr." ++ show screenNum
             )
           | (key, screenNum) <- zip numericKeys [0..]
           ]
           ++
           [ -- ───────────────────────────── layout management •2.09.04•    ──┤
             -- ──────────────────── switch ← layout management •2.09.04.01• ──┤
             ( (metaMask, xK_space)
             , XM.sendMessage XM.NextLayout
             , "rotate through the available layout algorithms"
             )
             -- TODO doesn't work
             --  , ( (metaMask .|. shiftMask, xK_space)
             --    , setLayout layoutHook
             --    , "reset the layouts on the current workspace to default"
             --    )
             -- ────────────────────────────────────────── execute •2.09.05• ──┤
           , ( (metaMask .|. shiftMask, xK_Return)
             , XM.spawn terminal
             , "open terminal"
             )
           , ( (metaMask, xK_p)
             , XM.spawn programLauncher
             , "open program launcher"
             )
           , ( (metaMask .|. altMask, xK_p)
             , xmonadCommands >>= Commands.runCommand
             , "run an internal xmonad command"
             )
           , ( (metaMask .|. shiftMask, xK_c)
             , CopyWindow.kill1
             , "close focused window (in the current workspace)"
             )
           , ( (metaMask .|. altMask .|. shiftMask, xK_c)
             , CopyWindow.killAllOtherCopies
             , "close all other copies of focused window"
             )
             -- ────────────────────────────────────── scratchpads •2.09.06• ──┤
           , ( (metaMask, xK_a)
             , Submap.submap $ Map.fromList
                 [ (kb, action)
                 | (kb, action, _) <- scratchpadsKeymaps
                 ]
             , "scratchpads"
             )
           , ( (metaMask .|. altMask, xK_a)
             , Prompt.mkXPromptWithModes customPrompts xpConfig
             , "set of custom prompts" -- TODO better desc
             )
             -- ─────────────────────────────────────────── search •2.09.07• ──┤
           , ( (metaMask, xK_s)
             , Submap.submap $ Map.fromList
                 [ (kb, Search.promptSearch Prompt.defaultXPConfig action)
                 | (kb, action, _) <- searchKeymaps
                 ]
             , "search prompt"
             )
           , ( (metaMask .|. shiftMask, xK_s)
             , Submap.submap $ Map.fromList
                 [ (kb, Search.selectSearch action)
                 | (kb, action, _) <- searchKeymaps
                 ]
             , "search from selection"
             )
             -- ───────────────────────────────────────────── help •2.09.08• ──┤
           , ( (metaMask .|. shiftMask, xK_slash)
             , XM.spawn $ xmessage help
             , "show available bindings"
             )
             -- ───────────────────────────────────── quit/restart •2.09.09• ──┤
           , ( (metaMask, xK_q)
             , XM.spawn recompileXMonad
             , "restart xmonad"
             )
           , ( (metaMask .|. shiftMask, xK_q)
             , XM.io $ exitWith ExitSuccess
             , "quit xmonad"
             )
           ]
  where
    numericKeys = [xK_1 .. xK_9] ++ [xK_0]

    programLauncher = "dmenu_run"

    recompileXMonad = " if type xmonad; then"
                   ++ "   xmonad --recompile &&"
                   ++ "   xmonad --restart;"
                   ++ " else"
                   ++ "   xmessage xmonad not in \\$PATH: \"$PATH\";"
                   ++ " fi"

    customPrompts = Launcher.defaultLauncherModes Launcher.LauncherConfig
                  { Launcher.pathToHoogle = "/usr/bin/hoogle"
                  , Launcher.browser      = "<%= local! :web_browser %>"
                  }
                  ++
                  [
                  -- insert the custom prompts here :)
                  ]

help :: String
help  = List.intercalate "\n" ( header
                                ++
                                [ ppKey ++ kdSep ++ ppDesc
                                | (ppKey, ppDesc) <- ppKeymaps
                                ]
                              )
  where
    header = [ title
             , concat $ replicate (length title) [titleSep]
             , ""
             ]
    title = "xmonad keymaps"
    titleSep = '─'

    kdSep = " : "

    ppKeymaps = [ppKeymap keymap allKeys allDescs | keymap <- allKeymaps]

    allKeymaps = mergeKeymaps rootKeymaps subKeymaps
    allKeys    = [(key, level) | (key, _,    level) <- allKeymaps]
    allDescs   = [desc         | (_,   desc, _)     <- allKeymaps]

    rootKeymaps = [(key, desc, RootLevel) | (key, _, desc) <- keymaps]
    subKeymaps  = [ ( "scratchpads"
                    , [ (key, desc, NestedLevel 1)
                      | (key, _, desc) <- scratchpadsKeymaps ]
                    )
                  , ( "search methods"
                    , [ (key, desc, NestedLevel 1)
                      | (key, _, desc) <- searchKeymaps ]
                    )
                  ]

scratchpadsKeymaps :: [((KeyMask, KeySym), X (), [Char])]
scratchpadsKeymaps  = [ ( (0, xK_t)
                        , Scratchpad.namedScratchpadAction scratchpads "term"
                        , "terminal"
                        )
                      , ( (0, xK_i)
                        , Scratchpad.namedScratchpadAction scratchpads "top"
                        , "process info"
                        )
                        <% if has_feature? :python %>
                      , ( (0, xK_p)
                        , Scratchpad.namedScratchpadAction scratchpads "ipython"
                        , "python repl"
                        )
                        <% end %>
                        <% if has_feature? :ruby %>
                      , ( (0, xK_r)
                        , Scratchpad.namedScratchpadAction scratchpads "irb"
                        , "ruby repl"
                        )
                        <% end %>
                        <% if has_feature? :haskell %>
                      , ( (0, xK_h)
                        , Scratchpad.namedScratchpadAction scratchpads "ghci"
                        , "haskell repl"
                        )
                        <% end %>
                      ]

searchKeymaps :: [((KeyMask, KeySym), Search.SearchEngine, [Char])]
searchKeymaps  = [ ( (0, xK_a)
                   , Search.alpha
                   , "wolfram alpha"
                   )
                 , ( (0, xK_c)
                   , Search.codesearch
                   , "google code"
                   )
                 , ( (0, xK_d)
                   , Search.dictionary
                   , "dictionary.com"
                   )
                 , ( (0, xK_g)
                   , Search.google
                   , "google search"
                   )
                 , ( (shiftMask, xK_h)
                   , Search.hackage
                   , "hackage"
                   )
                 , ( (0, xK_h)
                   , Search.hoogle
                   , "hoogle"
                   )
                 , ( (0, xK_i)
                   , Search.images
                   , "google images"
                   )
                 , ( (0, xK_m)
                   , Search.maps
                   , "google maps"
                   )
                 , ( (shiftMask, xK_m)
                   , Search.mathworld
                   , "mathworld"
                   )
                 , ( (0, xK_s)
                   , Search.scholar
                   , "google scholar"
                   )
                 , ( (0, xK_t)
                   , Search.thesaurus
                   , "thesaurus.com"
                   )
                 , ( (shiftMask, xK_w)
                   , Search.wayback
                   , "wayback"
                   )
                 , ( (0, xK_w)
                   , Search.wikipedia
                   , "wikipedia"
                   )
                 , ( (0, xK_y)
                   , Search.youtube
                   , "youtube"
                   )
                 , ( (0, xK_u)
                   , Search.multi
                   , "multi-search"
                   )
                 ]

xmonadCommands :: X [(String, X ())]
xmonadCommands  = Commands.defaultCommands

-- TODO
-- workspacePromptKeymap =
--  , ((0, xK_w), PW.workspacePrompt xpConfig (XM.windows . StackSet.greedyView))
--  , ("M-a M-w", PW.workspacePrompt xpConfig (XM.windows . StackSet.shift))
--  , ("M-a m",   PM.manPrompt  xpConfig)
--  , ("M-a d",   WorkspaceDir.changeDir xpConfig)
--  , ("M-a s",   PS.sshPrompt  xpConfig)

-- ─────────────────────────────────────────────────── mouse bindings •2.10• ──┤

mouseMaps :: [((KeyMask, Button), XM.Window -> X (), [Char])]
mouseMaps  = [ ( (metaMask, button1)
               , \w -> XM.focus w
                    >> XM.mouseMoveWindow w
                    >> FloatSnap.ifClick (snap w)
               , "move window (snapping to borders)"
               )
             , ( (metaMask .|. altMask, button1)
               , \w -> XM.focus w
                    >> FlexM.mouseWindow FlexM.linear w
                    >> FloatSnap.ifClick (snap w)
               , "scale/reposition the window (dynamic behavior by mouse pos)"
               )
             , ( (metaMask .|. shiftMask, button1)
               , \w -> XM.focus w
                    >> XM.mouseMoveWindow w
                    >> FloatSnap.ifClick (expandOnMove w)
               , "move window (expanding to borders)"
               )
             , ( (metaMask, button3)
               , \w -> XM.focus w
                    >> FlexR.mouseResizeWindow w
                    >> FloatSnap.ifClick (expandOnResize w)
               , "resize window (expanding to borders)"
               )
             , ( (metaMask .|. altMask, button3)
               , \w -> XM.focus w
                    >> ConstrResize.mouseResizeWindow w True
               , "resize window (keeping aspect ratio)")
             ]
  where
    snap           w = FloatSnap.snapMagicMove                distance distance w
    expandOnMove   w = FloatSnap.snapMagicResize allBorders   distance distance w
    expandOnResize w = FloatSnap.snapMagicResize resizeCorner distance distance w

    allBorders   = [FloatSnap.L, FloatSnap.R, FloatSnap.U, FloatSnap.D]
    resizeCorner = [FloatSnap.R, FloatSnap.D]

    distance = (Just 128)

-- ───────────────────────────────────────────────────────────── misc •2.11• ──┤

terminal :: String
terminal  = "<%= local! :term_open_cmd %>"

-- whether XM.focus follows the mouse pointer
shouldFocusFollowMouse :: Bool
shouldFocusFollowMouse  = True

-- whether a mouse click select the XM.focus or is just passed to the window
shouldClickJustFocus :: Bool
shouldClickJustFocus  = True

-- ─────────────────────────────────────────────────────────── prompt •2.12• ──┤

xpConfig :: Prompt.XPConfig
xpConfig  = Prompt.defaultXPConfig
          { Prompt.font        = toXft font
          , Prompt.borderColor = toHex inactiveBorderColor
          , Prompt.bgColor     = toHex inactiveBgColor
          , Prompt.fgColor     = toHex inactiveFgColor
          , Prompt.bgHLight    = toHex highlightBgColor
          , Prompt.fgHLight    = toHex highlightFgColor
          , Prompt.position    = Prompt.Top
          }

-- ─────────────────────────────────────────────────────────── colors •2.13• ──┤

colors :: ColorPalette
colors  = ColorPalette
        { <%= local!(:colorscheme).map do |name, hex|
            "#{name} = Hex \"#{hex}\""
          end.join(", ") %>
        }

inactiveBgColor :: Color
inactiveBgColor  = darkerGrey colors

inactiveFgColor :: Color
inactiveFgColor  = cyan colors

inactiveBorderColor :: Color
inactiveBorderColor  = cyan colors

activeBgColor :: Color
activeBgColor  = darkerGrey colors

activeFgColor :: Color
activeFgColor  = green colors

activeBorderColor :: Color
activeBorderColor  = green colors

highlightBgColor :: Color
highlightBgColor  = activeFgColor

highlightFgColor :: Color
highlightFgColor  = activeBgColor

urgentBgColor :: Color
urgentBgColor  = darkerGrey colors

urgentFgColor :: Color
urgentFgColor  = red colors

urgentBorderColor :: Color
urgentBorderColor  = red colors

-- ──────────────────────────────────────────────────────────── fonts •2.14• ──┤

font :: Font
font  = Font
      { name = "<%= local! :font_name %>"
      , size =  <%= local! :font_size %>
      }

-- ──────────────────────────────────────────────────────────── sizes •2.15• ──┤

windowBorderWidth :: XM.Dimension
windowBorderWidth  = 1

-- ────────────────────────────────────────────────────────────────────────────┘


-- ──────────────────────────────────────────────────────────────── misc •3• ──┐

-- ────────────────────────────────────────────────────── misc - font •3.01• ──┤

data Font = Font
          { name :: String
          , size :: Int
          }

toXft :: Font
      -> String

toXft (Font name size) = "xft:" ++ name ++ "-" ++ show size

-- ───────────────────────────────────────────────────── misc - color •3.01• ──┤

data Color = Hex String

toHex :: Color
      -> String

toHex (Hex hex) = hex

data ColorPalette = ColorPalette
                  { darkerGrey   :: Color
                  , darkGrey     :: Color
                  , grey         :: Color
                  , lightGrey    :: Color
                  , lighterGrey  :: Color
                  , darkRed      :: Color
                  , red          :: Color
                  , darkGreen    :: Color
                  , green        :: Color
                  , orange       :: Color
                  , yellow       :: Color
                  , blue         :: Color
                  , darkBlue     :: Color
                  , magenta      :: Color
                  , lightMagenta :: Color
                  , cyan         :: Color
                  , lightCyan    :: Color
                  }

-- ────────────────────────────────────────────────────── misc - xorg •3.03• ──┤

data XWindowQuery a = XWindowClass    a
                    | XWindowResource a
                    | XWindowTitle    a

checkXWindowQuery :: XWindowQuery String
                  -> XM.Query Bool

checkXWindowQuery (XWindowClass    a) = XM.className =? a
checkXWindowQuery (XWindowTitle    a) = XM.title     =? a
checkXWindowQuery (XWindowResource a) = XM.resource  =? a

-- ─────────────────────────────────────────────────── misc - keymaps •3.04• ──┤

data KeymapLevel = RootLevel
                 | NestedLevel Int

-- merge sub-keymaps with root-keymaps
mergeKeymaps :: Eq a
             => [(t, a, t1)]
             -> [(a, [(t, a, t1)])]
             -> [(t, a, t1)]

mergeKeymaps rootKeymaps subKeymaps = mergeKeymaps' [] rootKeymaps subKeymaps
  where
    mergeKeymaps' res []           _  = res
    mergeKeymaps' res rootKeymaps  [] = res ++ rootKeymaps
    mergeKeymaps' res (x@(_, rootKeymapDesc, _):xs) (y@(matchingDesc, subKeymaps):ys)
      | rootKeymapDesc == matchingDesc = mergeKeymaps' (res ++ [x] ++ subKeymaps) xs ys
      | otherwise                      = mergeKeymaps' (res ++ [x])               xs (y:ys)

-- pretty format a keymap and its descriptive text
ppKeymap :: Foldable t
         => ((KeyMask, KeySym), String, KeymapLevel)
         -> [((KeyMask, KeySym), KeymapLevel)]
         -> [t a]
         -> (String, String)

ppKeymap (key, desc, level) allKeys allDesc =
    ( ppKey  allKeys key level
    , ppDesc allDesc desc
    )
  where
    formatKey key level = (prefix level) ++ (unkeyify key)
      where
        prefix RootLevel       = concat $ replicate 0 indentStr
        prefix (NestedLevel l) = concat $ replicate l indentStr
        indentStr = "  •  "

    ppKey allKeys key level = padStr (maxKeyLength allKeys) (formatKey key level)

    maxKeyLength allKeys = maxLength
                         $ map (\k@(key, level) -> formatKey key level) allKeys

    ppDesc allDesc desc   = padStr (maxDescLength allDesc) desc
    maxDescLength allDesc = maxLength allDesc

-- stringify a keymap
unkeyify :: (KeyMask, KeySym)
         -> String

unkeyify (m,s) = let dp "" = ""
                     dp p  = p ++ " + "
                 in dp (vmask m) ++ XM.keysymToString s

vmask :: KeyMask
      -> String

vmask msk = List.intercalate " + "
          $ reverse
          $ fst
          $ foldr vmask' ([], msk) masks
  where
    masks = map (\m -> (m, show m)) [0..toEnum (bitSize msk - 1)] ++
            [ (lockMask,    "lock")
            , (controlMask, "ctrl")
            , (shiftMask,   "shift")
            , (mod5Mask,    "mod5")
            , (mod4Mask,    "meta")
            , (mod3Mask,    "scrolllock")
            , (mod2Mask,    "numlock")
            , (mod1Mask,    "alt")
            ]
    vmask'   _    a@( _, 0)                = a
    vmask' (m, s)   (ss, v) | v .&. m == m = (s:ss, v .&. complement m)
    vmask'   _         r                   = r

-- ───────────────────────────────────────────── misc - utils - tuple •3.05• ──┤

mapT :: (a -> b)
     -> (a, a)
     -> (b, b)

mapT f (a1, a2) = (f a1, f a2)

-- ────────────────────────────────────────────── misc - utils - list •3.06• ──┤

maxLength :: Foldable t
          => [t a]
          -> Int

maxLength a = maximum $ map length a

-- ──────────────────────────────────────────── misc - utils - string •3.07• ──┤

padStr :: Int
       -> String
       -> String

padStr n s
  | length s < n = s ++ replicate (n - length s) ' '
  | otherwise    = s

-- ────────────────────────────────────────────────── misc - xmessage •3.08• ──┤

xmessage :: String
         -> String

xmessage msg = "echo \"" ++ msg ++ "\" | xmessage -file -"

-- ────────────────────────────────────────────────────────────────────────────┘


-- vim: set filetype=eruby.haskell :
