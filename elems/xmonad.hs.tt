-- ────────────────────────────────────────────────────────────────────────────┐
--                                                                             │
-- Name:    elems/xmonad.hs.tt                                                 │
-- Summary: XMonad configuration.                                              │
-- Authors:                                                                    │
--   - Alessandro Molari <molari.alessandro@gmail.com> (alem0lars)             │
--                                                                             │
-- Project:                                                                    │
--   - Homepage:        https://github.com/alem0lars/configs-xmonad            │
--   - Getting started: see README.md in the project root folder               │
--                                                                             │
-- License: Apache v2.0 (see below)                                            │
--                                                                             │
-- ────────────────────────────────────────────────────────────────────────────┤
--                                                                             │
-- Licensed to the Apache Software Foundation (ASF) under one more contributor │
-- license agreements.  See the NOTICE file distributed with this work for     │
-- additional information regarding copyright ownership. The ASF licenses this │
-- file to you under the Apache License, Version 2.0 (the "License"); you may  │
-- not use this file except in compliance with the License.                    │
-- You may obtain a copy of the License at                                     │
--                                                                             │
--   http://www.apache.org/licenses/LICENSE-2.0                                │
--                                                                             │
-- Unless required by applicable law or agreed to in writing, software         │
-- distributed under the License is distributed on an "AS IS" BASIS, WITHOUT   │
-- WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.            │
-- See the License for the specific language governing permissions and         │
-- limitations under the License.                                              │
--                                                                             │
-- ────────────────────────────────────────────────────────────────────────────┤
<% define_locals do
  prefixed(:"xmonad.", as: nil) do
    variable :"terminal.open_cmd", as: :term_open_cmd
    variable :"terminal.run_cmd",  as: :term_run_cmd

    variable :workspace_dir

    variable :"font.name", as: :font_name
    variable :"font.size", as: :font_size, type: :int

    variable(:colorscheme) do |colorscheme|
      Hash[colorscheme.map { |name, hex| [name.camelize, hex] }]
    end
  end
end %>
-- ────────────────────────────────────────────────────────────────────────────┘


-- ┌───────────────────────────────────────────────────────────────────────────┐
-- │                            TABLE OF CONTENTS                              │
-- ├┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┤
-- │                                                                           │
-- │ ┌──→ •1• imports                                                          │
-- │ │                                                                         │
-- │ ├──→ •2• xconfig                                                          │
-- │ │     │                                                                   │
-- │ │     ├─→ •2.01• layouts                                                  │
-- │ │     ├─→ •2.02• workspaces                                               │
-- │ │     ├─→ •2.03• log hook                                                 │
-- │ │     ├─→ •2.04• statusbar                                                │
-- │ │     ├─→ •2.05• startup hook                                             │
-- │ │     ├─→ •2.06• handle event hook                                        │
-- │ │     ├─→ •2.07• manage hook                                              │
-- │ │     ├─→ •2.08• scratchpads                                              │
-- │ │     ├─→ •2.09• key bindings                                             │
-- │ │     ├─→ •2.10• mouse bindings                                           │
-- │ │     ├─→ •2.11• misc                                                     │
-- │ │     ├─→ •2.12• prompt                                                   │
-- │ │     ├─→ •2.13• colors                                                   │
-- │ │     ├─→ •2.14• fonts                                                    │
-- │ │     └─→ •2.15• sizes                                                    │
-- │ │                                                                         │
-- │ └──→ •3• types                                                            │
-- │                                                                           │
-- └───────────────────────────────────────────────────────────────────────────┘


-- ───────────────────────────────────────────────────────────── imports •1• ──┐

import System.Exit (ExitCode(ExitSuccess), exitWith)

import Data.Bits ((.&.), bitSize, complement)

import qualified Data.Map  as M
import qualified Data.List as L

import qualified Graphics.X11.Xlib.Misc as X

import XMonad

import qualified XMonad.Actions.DwmPromote        as ADP
import qualified XMonad.Actions.CycleRecentWS     as AWS
import qualified XMonad.Actions.Commands          as ACMD
import qualified XMonad.Actions.CopyWindow        as ACW
import qualified XMonad.Actions.ConstrainedResize as ACR
import qualified XMonad.Actions.FloatSnap         as AFS
import qualified XMonad.Actions.PhysicalScreens   as APS
import qualified XMonad.Actions.Search            as ASE
import qualified XMonad.Actions.Submap            as ASM

import qualified XMonad.Hooks.DynamicLog    as HDL
import qualified XMonad.Hooks.EwmhDesktops  as HEWMH
import qualified XMonad.Hooks.ICCCMFocus    as HICCCMF
import qualified XMonad.Hooks.ManageDocks   as HMD
import qualified XMonad.Hooks.ManageHelpers as HMH
import qualified XMonad.Hooks.Place         as HP
import qualified XMonad.Hooks.SetWMName     as HWMN
import qualified XMonad.Hooks.UrgencyHook   as HU

import qualified XMonad.Layout.Decoration            as LD
import qualified XMonad.Layout.MultiToggle           as LMT
import qualified XMonad.Layout.MultiToggle.Instances as LMTI
import qualified XMonad.Layout.NoBorders             as LNB
import qualified XMonad.Layout.PerWorkspace          as LPW
import qualified XMonad.Layout.Reflect               as LR
import qualified XMonad.Layout.Tabbed                as LT
import qualified XMonad.Layout.WorkspaceDir          as LWD

import qualified XMonad.ManageHook as MH

import qualified XMonad.Prompt           as P
import qualified XMonad.Prompt.Man       as PM
import qualified XMonad.Prompt.Ssh       as PS
import qualified XMonad.Prompt.Workspace as PW

import qualified XMonad.StackSet as SS

import qualified XMonad.Util.NamedScratchpad as SP
import qualified XMonad.Util.Run as R
import qualified XMonad.Util.EZConfig as EZ

-- TODO import qualified System.Taffybar.Hooks.PagerHints as TB

-- ────────────────────────────────────────────────────────────────────────────┘


-- ───────────────────────────────────────────────────────────── xconfig •2• ──┐

main = do myStatusBarHandle <- R.spawnPipe statusBarCmd
          xmonad $ HU.withUrgencyHook HU.NoUrgencyHook
                 $ HEWMH.ewmh
                 -- TODO $ TB.pagerHints
                 $ xConfig myStatusBarHandle
  where
    xConfig myStatusBarHandle = defaultConfig
      { XMonad.layoutHook         = myLayoutHook
      , XMonad.manageHook         = myManageHook
      , XMonad.handleEventHook    = myHandleEventHook
      , XMonad.logHook            = myLogHook myStatusBarHandle
      , XMonad.startupHook        = myStartupHook
      , XMonad.workspaces         = myWorkspaces
      , XMonad.modMask            = metaMask
      , XMonad.focusFollowsMouse  = shouldFocusFollowMouse
      , XMonad.clickJustFocuses   = shouldClickJustFocus
      , XMonad.borderWidth        = windowBorderWidth
      , XMonad.normalBorderColor  = toHex normalWindowBorderColor
      , XMonad.focusedBorderColor = toHex focusedWindowBorderColor
      , XMonad.terminal           = myTerminal
      , XMonad.keys               = keymapConfig
      , XMonad.mouseBindings      = mousemapConfig
      }

    mousemapConfig = \conf@(XConfig {XMonad.modMask = modMask}) -> M.fromList
      [ (key, action)
      | (key, action, desc) <- mouseMaps
      ]
    keymapConfig = \conf@(XConfig {XMonad.modMask = modMask}) -> M.fromList
      [ (key, action)
      | (key, action, _) <- keymaps
      ]

-- ────────────────────────────────────────────────────────── layouts •2.01• ──┤

myLayoutHook = LNB.smartBorders . HMD.avoidStruts
             $ LWD.workspaceDir workspaceDir
             $ LMT.mkToggle1 LMTI.NBFULL    -- switch to full with no borders
             $ LMT.mkToggle1 LR.REFLECTX    -- reflect x-axis
             $ LMT.mkToggle1 LR.REFLECTY    -- reflect y-axis
             $ LMT.mkToggle1 LMTI.NOBORDERS -- remove borders
             $ LMT.mkToggle1 LMTI.MIRROR    -- mirror the current layout
             $ LPW.onWorkspace (myWorkspaces !! 0) myRefLayouts
             $ LPW.onWorkspace (myWorkspaces !! 1) myWflowLayouts
             $ LPW.onWorkspace (myWorkspaces !! 2) myWflowLayouts
             $ LPW.onWorkspace (myWorkspaces !! 3) myWflowsuppLayouts
             $ LPW.onWorkspace (myWorkspaces !! 4) myOrgLayouts
             $ LPW.onWorkspace (myWorkspaces !! 5) mySocialLayouts
             $ LPW.onWorkspace (myWorkspaces !! 6) myPlayLayouts
             $ LPW.onWorkspace (myWorkspaces !! 7) myMgmtLayouts
             $ LPW.onWorkspace (myWorkspaces !! 8) myTmpLayouts
             $ LPW.onWorkspace (myWorkspaces !! 9) myComboLayouts
             $ myDefaultLayouts
  where
    workspaceDir = "<%= File.expand_path local!(:workspace_dir) %>"

    -- Layout groups
    tabbedLayout = LT.tabbed LT.shrinkText $ LT.defaultTheme
                 { LT.inactiveBorderColor = toHex normalWindowBorderColor
                 , LT.activeBorderColor   = toHex focusedWindowBorderColor
                 , LT.activeTextColor     = toHex focusedWindowTextColor
                 , LT.urgentBorderColor   = toHex urgentBorderColor
                 , LT.urgentTextColor     = toHex urgentTextColor
                 }
    -- TODO: decide
    myRefLayouts       = tabbedLayout ||| myGridLayout
    myWflowLayouts     = myOneBigLayout ||| myMosaicLayout ||| myGridLayout ||| tabbedLayout
    myWflowsuppLayouts = tabbedLayout ||| myGridLayout ||| myOneBigLayout ||| myMosaicLayout
    myOrgLayouts       = tabbedLayout ||| myGridLayout
    mySocialLayouts    = tabbedLayout ||| myGridLayout
    myPlayLayouts      = tabbedLayout ||| myGridLayout
    myMgmtLayouts      = myGridLayout ||| myOneBigLayout ||| tabbedLayout
    myTmpLayouts       = myGridLayout ||| tabbedLayout
    myComboLayouts     = tabbedLayout
    myDefaultLayouts   = myWflowLayouts

    -- Layout definitions
    myCrossLayout     = Full -- TODO simpleCross
    myFullLayout      = Full -- TODO Full
    myAccordionLayout = Full -- TODO Accordion
    myGridLayout      = Full -- TODO Grid
    mySpiralLayout    = Full -- TODO spiral (1/2)
    myMosaicLayout    = Full -- TODO mosaic 2 [3, 2]
    myFloatLayout     = Full -- TODO simpleFloat
    myOneBigLayout    = Full -- TODO OneBig 0.6 0.74

-- ─────────────────────────────────────────────────────── workspaces •2.02• ──┤

myWorkspaces = zipWith (++) workspaceIds
             $ map (sep ++) workspaceNames
  where
    workspaceIds = [ (show workspaceIndex)  ++ delimiter
                   | workspaceIndex <- [1..]
                   ]
    delimiter = "•"
    sep = ""
    workspaceNames = [ "ref"
                     , "wf"
                     , "wf"
                     , "wfs"
                     , "org"
                     , "social"
                     , "play"
                     , "mgmt"
                     , "tmp"
                     , "combo"
                     ]

-- ───────────────────────────────────────────────────────── log hook •2.03• ──┤

myLogHook h = do copies <- ACW.wsContainingCopies
                 HICCCMF.takeTopFocus >> HDL.dynamicLogWithPP (statusPP h copies)

statusBarCmd = "/usr/bin/xmobar"

statusPP h copies = HDL.defaultPP
                  { HDL.ppCurrent         = format currentColor currentSymbols
                  , HDL.ppVisible         = format visibleColor visibleSymbols
                  , HDL.ppHidden          = formatHidden copies
                  , HDL.ppHiddenNoWindows = format emptyColor   emptySymbols
                  , HDL.ppUrgent          = format urgentColor  urgentSymbols
                  , HDL.ppLayout          = format layoutColor  layoutSymbols
                                          . take 16 -- Maximum layout name (TODO to be computed automatically)
                                          . (++ repeat ' ')
                  , HDL.ppSep    = "  "
                  , HDL.ppWsSep  = " "
                  , HDL.ppTitle  = take 0
                  , HDL.ppOutput = R.hPutStrLn h
                  }
  where
    formatHidden copies ws | (ws `elem` copies) = format hiddenWithCopiesColor hiddenSymbols ws
                           | otherwise          = format hiddenColor           hiddenSymbols ws
    -- utility function: surround with symbols and apply colors
    format colorSpec symbolSpec = uncurry HDL.xmobarColor (mapT toHex colorSpec)
                                . uncurry HDL.wrap symbolSpec

    currentColor   = (bgColor, green colors)
    currentSymbols = (" ◄ ", " ► ")

    visibleColor   = (bgColor, orange colors)
    visibleSymbols = (" |", "| ")

    hiddenWithCopiesColor = (bgColor, yellow colors)
    hiddenColor           = (bgColor, cyan colors)
    hiddenSymbols         = (" ⟨ ", " ⟩ ")

    emptyColor   = (bgColor, grey colors)
    emptySymbols = (" ∅ ", " ∅ ")

    urgentColor   = (bgColor, red colors)
    urgentSymbols = (" ! ", " ! ")

    layoutColor   = (bgColor, magenta colors)
    layoutSymbols = (" λ ", " λ ")

-- ───────────────────────────────────────────────────── startup hook •2.05• ──┤

myStartupHook = HEWMH.ewmhDesktopsStartup >> HWMN.setWMName "LG3D"

-- ──────────────────────────────────────────────── handle event hook •2.06• ──┤

myHandleEventHook =  handleEventHook defaultConfig
                 <+> HMD.docksEventHook
                 <+> HEWMH.ewmhDesktopsEventHook
                 <+> HEWMH.fullscreenEventHook

-- ────────────────────────────────────────────────────── manage hook •2.07• ──┤

myManageHook =  HP.placeHook floatingWindowPlacement
            <+> basicManageHook
            <+> manageHook defaultConfig

floatingWindowPlacement = HP.withGaps (16, 0, 16, 0)
                        $ HP.smart (0.5, 0.5)

basicManageHook = composeAll . concat $
                [ [HMD.manageDocks]
                , [SP.namedScratchpadManageHook scratchpads]
                , [HMH.isFullscreen --> applyFullFloat]
                , [HMH.isDialog --> applyFloat]
                , [checkXWindowQuery q --> applyFloat | q      <- floats]
                , [checkXWindowQuery q --> doShift w  | (q, w) <- shifts]
                ]
  where
    applyFullFloat = HMH.doFullFloat
    applyFloat     = doFloat

    floats = [ XWindowClass "Pavucontrol"
             , XWindowClass "copyq"
             , XWindowClass "Xmessage"
             , XWindowClass "TeamViewer.exe"
             , XWindowTitle "Save As..."
             ]

    shifts = [ (XWindowClass "Firefox",                   myWorkspaces !! 0)
             , (XWindowClass "chromium-browser-chromium", myWorkspaces !! 0)
             ]

-- ────────────────────────────────────────────────────── scratchpads •2.08• ──┤

scratchpadSize = SS.RationalRect (1 / 4) (1 / 4) (1 / 2) (1 / 2)

scratchpadFloat = SP.customFloating scratchpadSize

scratchpads = [ SP.NS "term" myTerminal (title =? "term") scratchpadFloat
            , SP.NS "top" (runCmd "htop") (title =? "htop") scratchpadFloat
            <% if has_feature? :python %>
            , SP.NS "ipython" (runCmd "ipython") (title =? "ipython") scratchpadFloat
            <% end %>
            <% if has_feature? :ruby %>
            , SP.NS "irb" (runCmd "irb") (title =? "irb") scratchpadFloat
            <% end %>
            <% if has_feature? :haskell %>
            , SP.NS "ghci" (runCmd "ghci") (title =? "ghci") scratchpadFloat
            <% end %>
            ]
  where
    runCmd cmd = "<%= local! :term_run_cmd %> " ++ cmd

-- ───────────────────────────────────────────────────── key bindings •2.09• ──┤

metaMask = mod4Mask
altMask   = mod1Mask

keymaps :: [((KeyMask, KeySym), X (), String)]
keymaps = [ -- window management: change focus
            ( (metaMask, xK_Tab)
            , windows SS.focusDown
            , "move focus to the next window"
            )
          , ( (metaMask .|. shiftMask, xK_Tab)
            , windows SS.focusUp
            , "move focus to the previous window"
            )
          , ( (metaMask, xK_j)
            , windows SS.focusDown
            , "move focus to the next window"
            )
          , ( (metaMask, xK_k)
            , windows SS.focusUp
            , "move focus to the previous window"
            )
            -- window management: swap
          , ( (metaMask, xK_Return)
            , ADP.dwmpromote
            , "swap focused window with the master window"
            )
          , ( (metaMask .|. shiftMask, xK_j)
            , windows SS.swapDown
            , "swap the focused window with the next window"
            )
          , ( (metaMask .|. shiftMask, xK_k)
            , windows SS.swapUp
            , "swap the focused window with the previous window"
            )
            -- window management: resize
          , ( (metaMask, xK_n)
            , refresh
            , "resize viewed windows to the correct size"
            )
          , ( (metaMask, xK_h)
            , sendMessage Shrink
            , "shrink the master area"
            )
          , ( (metaMask, xK_l)
            , sendMessage Expand
            , "expand the master area"
            )
            -- window management: cycle through windows
          , ( (metaMask .|. controlMask, xK_Tab)
            , AWS.cycleRecentWS [xK_Alt_L] xK_Tab xK_grave
            , "cycle through most recent workspaces"
            )
            -- window management: float windows support
          , ( (metaMask .|. altMask, xK_r)
            , HP.placeFocused floatingWindowPlacement
            , "manually reposition focused floating window"
            )
          , ( (metaMask, xK_t)
            , withFocused $ windows . SS.sink
            , "push window back into tiling"
            )
            -- window management: work with master/slave windows
          , ( (metaMask, xK_m)
            , windows SS.focusMaster
            , "move focus to the master window"
            )
          , ( (metaMask, xK_comma)
            , sendMessage (IncMasterN 1)
            , "increment the number of windows in the master area"
            )
          , ( (metaMask, xK_period)
            , sendMessage (IncMasterN (-1))
            , "deincrement the number of windows in the master area"
            )
            -- layout
          , ( (metaMask, xK_space)
            , sendMessage NextLayout
            , "rotate through the available layout algorithms"
            )
        -- TODO doesn't work
        --  , ( (metaMask .|. shiftMask, xK_space)
        --    , setLayout myLayoutHook
        --    , "reset the layouts on the current workspace to default"
        --    )
            -- launch
          , ( (metaMask .|. controlMask, xK_p)
            , xmonadCommands >>= ACMD.runCommand
            , "run an internal xmonad command"
            )
          , ( (metaMask .|. shiftMask, xK_Return)
            , spawn myTerminal
            , "open terminal"
            )
          , ( (metaMask, xK_p)
            , spawn programLauncher
            , "open program launcher"
            )
          , ( (metaMask .|. shiftMask, xK_c)
            , ACW.kill1
            , "close focused window (in the current workspace)"
            )
          , ( (metaMask .|. altMask .|. shiftMask, xK_c)
            , ACW.killAllOtherCopies
            , "close all other copies of focused window"
            )
            -- scratchpads
          , ( (metaMask, xK_a)
            , ASM.submap . M.fromList $ [ (kb, action)
                                        | (kb, action, _) <- scratchpadsKeymaps]
            , "scratchpads"
            )
            -- search
          , ( (metaMask, xK_s)
            , ASM.submap $ (M.fromList [ (kb, ASE.promptSearch P.defaultXPConfig action)
                                       | (kb, action, _) <- searchKeymaps
                                       ])
            , "search prompt"
            )
          , ( (metaMask .|. shiftMask, xK_s)
            , ASM.submap $ (M.fromList [ (kb, ASE.selectSearch action)
                                       | (kb, action, _) <- searchKeymaps
                                       ])
            , "search from selection"
            )
            -- help
          , ( (metaMask .|. shiftMask, xK_slash)
            , spawn $ xmessage help
            , "show available bindings"
            )
            -- quit / restart
          , ( (metaMask .|. shiftMask, xK_q)
            , io $ exitWith ExitSuccess
            , "quit xmonad"
            )
          , ( (metaMask, xK_q)
            , spawn recompileXMonad
            , "restart xmonad"
            )
          ]
          ++ -- switch/move window to previous/next screen
          [ ( (metaMask, xK_w)
            , APS.onPrevNeighbour SS.view
            , "switch to the previous screen"
            )
          , ( (metaMask, xK_e)
            , APS.onNextNeighbour SS.view
            , "switch to the next screen"
            )
          , ( (metaMask .|. shiftMask, xK_w)
            , APS.onPrevNeighbour SS.shift
            , "move focused window to the previous screen"
            )
          , ( (metaMask .|. shiftMask, xK_e)
            , APS.onNextNeighbour SS.shift
            , "move focused window to the next screen"
            )
          ]
          ++ -- switch screens
          [ ( (metaMask .|. altMask, key)
            , screenWorkspace screenNum >>= flip whenJust (windows . SS.view)
            , "switch to screen nr." ++ show screenNum
            )
          | (key, screenNum) <- zip ([xK_1 .. xK_9] ++ [xK_0]) [0..]
          ]
          ++ -- move focused window to another screen
          [ ( (metaMask .|. altMask .|. shiftMask, key)
            , screenWorkspace screenNum >>= flip whenJust (windows . SS.shift)
            , "switch to screen nr." ++ show screenNum
            )
          | (key, screenNum) <- zip ([xK_1 .. xK_9] ++ [xK_0]) [0..]
          ]
          ++ -- switch workspaces
          [ ( (metaMask, key)
            , windows $ SS.greedyView workspace
            , "switch to workspace '" ++ workspace ++ "'" ++ " (nr." ++ show num ++ ")"
            )
          | (workspace, key, num) <- zip3 myWorkspaces ([xK_1 .. xK_9] ++ [xK_0]) [1..]
          ]
          ++ -- move focused window to another workspace
          [ ( (metaMask .|. shiftMask, key)
            , windows $ SS.shift workspace
            , "move focused window to workspace '" ++ workspace ++ "'" ++ " (nr." ++ show num ++ ")"
            )
          | (workspace, key, num) <- zip3 myWorkspaces ([xK_1 .. xK_9] ++ [xK_0]) [1..]
          ]
          ++ -- copy focused window to another workspace
          [ ( (metaMask .|. controlMask .|. shiftMask, key)
            , windows $ ACW.copy workspace
            , "copy focused window to workspace '" ++ workspace ++ "'" ++ " (nr." ++ show num ++ ")"
            )
          | (workspace, key, num) <- zip3 myWorkspaces ([xK_1 .. xK_9] ++ [xK_0]) [1..]
          ]
  where
    programLauncher = "dmenu_run"

    recompileXMonad = "if type xmonad; then xmonad --recompile && xmonad --restart; else xmessage xmonad not in \\$PATH: \"$PATH\"; fi"

help = L.intercalate "\n" (header ++ [ppKey ++ kdSep ++ ppDesc | (ppKey, ppDesc) <- ppKeymaps])
  where
    header = [title
             , concat $ replicate (length title) [titleSep]
             , ""
             ]
    title = "xmonad keymaps"
    titleSep = '─'

    kdSep = " : "

    ppKeymaps = [ppKeymap keymap allKeys allDescs | keymap <- allKeymaps]

    allKeymaps = mergeKeymaps rootKeymaps subKeymaps
    allKeys    = [(key, level) | (key, _,    level) <- allKeymaps]
    allDescs   = [desc         | (_,   desc, _)     <- allKeymaps]

    rootKeymaps = [(key, desc, RootLevel) | (key, _, desc) <- keymaps]
    subKeymaps  = [ ( "scratchpads"
                    , [ (key, desc, NestedLevel 1)
                      | (key, _, desc) <- scratchpadsKeymaps ]
                    )
                  , ( "search methods"
                    , [ (key, desc, NestedLevel 1)
                      | (key, _, desc) <- searchKeymaps ]
                    )
                  ]

scratchpadsKeymaps = [ ( (0, xK_t)
                       , SP.namedScratchpadAction scratchpads "term"
                       , "terminal"
                       )
                     , ( (0, xK_i)
                       , SP.namedScratchpadAction scratchpads "top"
                       , "process info"
                       )
                       <% if has_feature? :python %>
                     , ( (0, xK_p)
                       , SP.namedScratchpadAction scratchpads "ipython"
                       , "python repl"
                       )
                       <% end %>
                       <% if has_feature? :ruby %>
                     , ( (0, xK_r)
                       , SP.namedScratchpadAction scratchpads "irb"
                       , "ruby repl"
                       )
                       <% end %>
                       <% if has_feature? :haskell %>
                     , ( (0, xK_h)
                       , SP.namedScratchpadAction scratchpads "ghci"
                       , "haskell repl"
                       )
                       <% end %>
                     ]

searchKeymaps = [ ( (0, xK_a)
                  , ASE.alpha
                  , "wolfram alpha"
                  )
                , ( (0, xK_c)
                  , ASE.codesearch
                  , "google code"
                  )
                , ( (0, xK_d)
                  , ASE.dictionary
                  , "dictionary.com"
                  )
                , ( (0, xK_g)
                  , ASE.google
                  , "google search"
                  )
                , ( (0, xK_H)
                  , ASE.hackage
                  , "hackage"
                  )
                , ( (0, xK_h)
                  , ASE.hoogle
                  , "hoogle"
                  )
                , ( (0, xK_i)
                  , ASE.images
                  , "google images"
                  )
                , ( (0, xK_m)
                  , ASE.maps
                  , "google maps"
                  )
                , ( (0, xK_M)
                  , ASE.mathworld
                  , "mathworld"
                  )
                , ( (0, xK_s)
                  , ASE.scholar
                  , "google scholar"
                  )
                , ( (0, xK_t)
                  , ASE.thesaurus
                  , "thesaurus.com"
                  )
                , ( (0, xK_W)
                  , ASE.wayback
                  , "wayback"
                  )
                , ( (0, xK_w)
                  , ASE.wikipedia
                  , "wikipedia"
                  )
                , ( (0, xK_y)
                  , ASE.youtube
                  , "youtube"
                  )
                , ( (0, xK_u)
                  , ASE.multi
                  , "multi-search"
                  )
                ]

xmonadCommands :: X [(String, X ())]
xmonadCommands = ACMD.defaultCommands

-- TODO
-- workspacePromptKeymap =
--  , ((0, xK_w), PW.workspacePrompt xpConfig (windows . SS.greedyView))
--  , ("M-a M-w", PW.workspacePrompt xpConfig (windows . SS.shift))
--  , ("M-a m",   PM.manPrompt  xpConfig)
--  , ("M-a d",   LWD.changeDir xpConfig)
--  , ("M-a s",   PS.sshPrompt  xpConfig)

-- ─────────────────────────────────────────────────── mouse bindings •2.10• ──┤

mouseMaps = [ ( (metaMask, button1)
              , \w -> focus w >>
                      mouseMoveWindow w >>
                      AFS.snapMagicMove (Just 50) (Just 50) w
              , "Move window"
              )
            , ( (metaMask .|. shiftMask, button1)
              , \w -> focus w >>
                      mouseMoveWindow w >>
                      AFS.snapMagicResize [AFS.L, AFS.R, AFS.U, AFS.D]
                                          (Just 50) (Just 50) w
              , "Expand window"
              )
            , ( (metaMask, button3)
              , \w -> focus w >>
                      mouseResizeWindow w >>
                      AFS.snapMagicResize [AFS.R, AFS.D] (Just 50) (Just 50) w
              , "resize window"
              )
            , ( (metaMask .|. altMask, button3)
              , \w -> focus w >> ACR.mouseResizeWindow w True
              , "resize window (keeping aspect ratio)")
            ]

-- ───────────────────────────────────────────────────────────── misc •2.11• ──┤

myTerminal = "<%= local! :term_open_cmd %>"

-- whether focus follows the mouse pointer
shouldFocusFollowMouse = True

-- whether a mouse click select the focus or is just passed to the window
shouldClickJustFocus = True

-- ─────────────────────────────────────────────────────────── prompt •2.12• ──┤

xpConfig = P.defaultXPConfig
         { P.font        = toXft font
         , P.bgColor     = toHex bgColor
         , P.fgColor     = toHex fgColor
         , P.bgHLight    = toHex bgHighlightColor
         , P.fgHLight    = toHex fgHighlightColor
         , P.borderColor = toHex normalWindowBorderColor
         , P.position    = P.Top
         }

-- ─────────────────────────────────────────────────────────── colors •2.13• ──┤

colors = ColorPalette
       { <%= local!(:colorscheme).map do |name, hex|
           "#{name} = Hex \"#{hex}\""
         end.join(", ") %>
       }

normalWindowBorderColor = grey colors

focusedWindowBorderColor = darkBlue colors
focusedWindowTextColor   = cyan colors

urgentBorderColor = magenta colors
urgentTextColor   = lightMagenta colors

bgColor = darkerGrey colors
fgColor = lightGrey colors

bgHighlightColor = darkGrey colors
fgHighlightColor = lighterGrey colors

-- ──────────────────────────────────────────────────────────── fonts •2.14• ──┤

font = Font
     { name = "<%= local! :font_name %>"
     , size =  <%= local! :font_size %>
     }

-- ──────────────────────────────────────────────────────────── sizes •2.15• ──┤

windowBorderWidth = 1

-- ────────────────────────────────────────────────────────────────────────────┘


-- ──────────────────────────────────────────────────────────────── misc •3• ──┐

-- ────────────────────────────────────────────────────── misc - font •3.01• ──┤
data Font = Font
          { name :: String
          , size :: Int
          }

toXft (Font name size) = "xft:" ++ name ++ "-" ++ show size

-- ───────────────────────────────────────────────────── misc - color •3.01• ──┤

data MyColor = Hex String

toHex :: MyColor -> String
toHex (Hex hex) = hex

data ColorPalette = ColorPalette
                  { darkerGrey   :: MyColor
                  , darkGrey     :: MyColor
                  , grey         :: MyColor
                  , lightGrey    :: MyColor
                  , lighterGrey  :: MyColor
                  , darkRed      :: MyColor
                  , red          :: MyColor
                  , darkGreen    :: MyColor
                  , green        :: MyColor
                  , orange       :: MyColor
                  , yellow       :: MyColor
                  , blue         :: MyColor
                  , darkBlue     :: MyColor
                  , magenta      :: MyColor
                  , lightMagenta :: MyColor
                  , cyan         :: MyColor
                  , lightCyan    :: MyColor
                  }

-- ────────────────────────────────────────────────────── misc - xorg •3.03• ──┤

data XWindowQuery a = XWindowClass    a
                    | XWindowResource a
                    | XWindowTitle    a

checkXWindowQuery (XWindowClass    a) = className =? a
checkXWindowQuery (XWindowTitle    a) = title     =? a
checkXWindowQuery (XWindowResource a) = resource  =? a

-- ─────────────────────────────────────────────────── misc - keymaps •3.04• ──┤

data KeymapLevel = RootLevel
                 | NestedLevel Int

-- merge sub-keymaps with root-keymaps
mergeKeymaps rootKeymaps subKeymaps = mergeKeymaps' [] rootKeymaps subKeymaps
  where
    mergeKeymaps' res []           _  = res
    mergeKeymaps' res rootKeymaps  [] = res ++ rootKeymaps
    mergeKeymaps' res (x@(_, rootKeymapDesc, _):xs) (y@(matchingDesc, subKeymaps):ys)
      | rootKeymapDesc == matchingDesc = mergeKeymaps' (res ++ [x] ++ subKeymaps) xs ys
      | otherwise                      = mergeKeymaps' (res ++ [x])               xs (y:ys)

-- pretty format a keymap and its descriptive text
ppKeymap (key, desc, level) allKeys allDesc = (ppKey allKeys key level, ppDesc allDesc desc)
  where
    formatKey key level = (prefix level) ++ (unkeyify key)
      where
        prefix RootLevel       = concat $ replicate 0 indentStr
        prefix (NestedLevel l) = concat $ replicate l indentStr
        indentStr = "  •  "

    ppKey allKeys key level = padStr (maxKeyLength allKeys) (formatKey key level)

    maxKeyLength allKeys = maxLength
                         $ map (\k@(key, level) -> formatKey key level) allKeys

    ppDesc allDesc desc   = padStr (maxDescLength allDesc) desc
    maxDescLength allDesc = maxLength allDesc

-- stringify a keymap
unkeyify :: (KeyMask, KeySym) -> String
unkeyify (m,s) = let dp "" = ""
                     dp p  = p ++ " + "
                 in dp (vmask m) ++ keysymToString s

vmask :: KeyMask -> String
vmask msk = L.intercalate " + "
          $ reverse
          $ fst
          $ foldr vmask' ([], msk) masks
  where
    masks = map (\m -> (m, show m)) [0..toEnum (bitSize msk - 1)] ++
            [ (lockMask,    "lock")
            , (controlMask, "ctrl")
            , (shiftMask,   "shift")
            , (mod5Mask,    "mod5")
            , (mod4Mask,    "meta")
            , (mod3Mask,    "scrolllock")
            , (mod2Mask,    "numlock")
            , (mod1Mask,    "alt")
            ]
    vmask'   _    a@( _, 0)                = a
    vmask' (m, s)   (ss, v) | v .&. m == m = (s:ss, v .&. complement m)
    vmask'   _         r                   = r

-- ───────────────────────────────────────────── misc - utils - tuple •3.05• ──┤

mapT :: (a -> b) -> (a, a) -> (b, b)
mapT f (a1, a2) = (f a1, f a2)

-- ────────────────────────────────────────────── misc - utils - list •3.06• ──┤

maxLength a = maximum $ map length a

-- ──────────────────────────────────────────── misc - utils - string •3.07• ──┤

padStr :: Int -> String -> String
padStr n s
  | length s < n = s ++ replicate (n - length s) ' '
  | otherwise    = s

-- ────────────────────────────────────────────────── misc - xmessage •3.08• ──┤

xmessage msg = "echo \"" ++ msg ++ "\" | xmessage -file -"

-- ────────────────────────────────────────────────────────────────────────────┘


-- vim: set filetype=eruby.haskell :
