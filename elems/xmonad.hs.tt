-- ────────────────────────────────────────────────────────────────────────────┐
--                                                                             │
-- Name:    elems/xmonad.hs.tt                                                 │
-- Summary: XMonad configuration.                                              │
-- Authors:                                                                    │
--   - Alessandro Molari <molari.alessandro@gmail.com> (alem0lars)             │
--                                                                             │
-- Project:                                                                    │
--   - Homepage:        https://github.com/alem0lars/configs-xmonad            │
--   - Getting started: see README.md in the project root folder               │
--                                                                             │
-- License: Apache v2.0 (see below)                                            │
--                                                                             │
-- ────────────────────────────────────────────────────────────────────────────┤
--                                                                             │
-- Licensed to the Apache Software Foundation (ASF) under one more contributor │
-- license agreements.  See the NOTICE file distributed with this work for     │
-- additional information regarding copyright ownership. The ASF licenses this │
-- file to you under the Apache License, Version 2.0 (the "License"); you may  │
-- not use this file except in compliance with the License.                    │
-- You may obtain a copy of the License at                                     │
--                                                                             │
--   http://www.apache.org/licenses/LICENSE-2.0                                │
--                                                                             │
-- Unless required by applicable law or agreed to in writing, software         │
-- distributed under the License is distributed on an "AS IS" BASIS, WITHOUT   │
-- WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.            │
-- See the License for the specific language governing permissions and         │
-- limitations under the License.                                              │
--                                                                             │
-- ────────────────────────────────────────────────────────────────────────────┤
<% define_locals do
  prefixed(:"xmonad.", as: nil) do
    variable :"terminal.open_cmd", as: :term_open_cmd
    variable :"terminal.run_cmd",  as: :term_run_cmd

    variable :workspace_dir

    variable :"font.name", as: :font_name
    variable :"font.size", as: :font_size, type: :int

    variable(:colorscheme) do |colorscheme|
      Hash[colorscheme.map { |name, hex| [name.camelize, hex] }]
    end
  end
end %>
-- ────────────────────────────────────────────────────────────────────────────┘


-- ┌───────────────────────────────────────────────────────────────────────────┐
-- │                            TABLE OF CONTENTS                              │
-- ├┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┤
-- │                                                                           │
-- │ ┌──→ •1• imports                                                          │
-- │ │                                                                         │
-- │ ├──→ •2• xconfig                                                          │
-- │ │     │                                                                   │
-- │ │     ├─→ •2.01• layouts                                                  │
-- │ │     ├─→ •2.02• workspaces                                               │
-- │ │     ├─→ •2.03• log hook                                                 │
-- │ │     ├─→ •2.04• statusbar                                                │
-- │ │     ├─→ •2.05• startup hook                                             │
-- │ │     ├─→ •2.06• handle event hook                                        │
-- │ │     ├─→ •2.07• manage hook                                              │
-- │ │     ├─→ •2.08• scratchpads                                              │
-- │ │     ├─→ •2.09• key bindings                                             │
-- │ │     ├─→ •2.10• mouse bindings                                           │
-- │ │     ├─→ •2.11• misc                                                     │
-- │ │     ├─→ •2.12• prompt                                                   │
-- │ │     ├─→ •2.13• colors                                                   │
-- │ │     ├─→ •2.14• fonts                                                    │
-- │ │     └─→ •2.15• sizes                                                    │
-- │ │                                                                         │
-- │ └──→ •3• types                                                            │
-- │                                                                           │
-- └───────────────────────────────────────────────────────────────────────────┘


-- ───────────────────────────────────────────────────────────── imports •1• ──┐

import System.Exit (ExitCode(ExitSuccess), exitWith)

import Data.Bits ((.&.), bitSize, complement)

import qualified Data.Map  as M
import qualified Data.List as L

import XMonad ( xmonad
              , X
              , (|||)
              , (.|.)
              , (<+>)
              , (-->)
              , (=?)
              , KeyMask, KeySym -- keymap data types
              , xK_a, xK_b, xK_c, xK_d, xK_e, xK_f, xK_g, xK_h, xK_i
              , xK_j, xK_k, xK_l, xK_m, xK_n, xK_o, xK_p, xK_q, xK_r, xK_s
              , xK_t, xK_u, xK_v, xK_w, xK_x, xK_y, xK_z
              , xK_1, xK_2, xK_3, xK_4, xK_5, xK_6, xK_7, xK_8, xK_9, xK_0
              , xK_Tab, xK_Return, xK_grave, xK_comma, xK_space, xK_period
              , xK_slash, xK_Alt_L
              , xK_Left, xK_Right, xK_Up, xK_Down
              , mod1Mask, mod2Mask, mod3Mask, mod4Mask, mod5Mask
              , shiftMask, controlMask, lockMask
              , button1, button2, button3 -- buttons
              )
import qualified XMonad.Core as XMonad
import qualified XMonad      as XM

import qualified XMonad.Actions.UpdatePointer      as UpdatePointer
import qualified XMonad.Actions.DwmPromote         as Promote
import qualified XMonad.Actions.CycleRecentWS      as CycleRecentWS
import qualified XMonad.Actions.Commands           as Commands
import qualified XMonad.Actions.CopyWindow         as CopyWindow
import qualified XMonad.Actions.ConstrainedResize  as ConstrResize
import qualified XMonad.Actions.FloatSnap          as FloatSnap
import qualified XMonad.Actions.PhysicalScreens    as PhyScreens
import qualified XMonad.Actions.Search             as Search
import qualified XMonad.Actions.Submap             as Submap
import qualified XMonad.Actions.FlexibleManipulate as FlexM
import qualified XMonad.Actions.FlexibleResize     as FlexR
import qualified XMonad.Actions.RotSlaves          as RotSlaves

import qualified XMonad.Hooks.DynamicLog    as DynLog
import qualified XMonad.Hooks.EwmhDesktops  as EWMH
import qualified XMonad.Hooks.ICCCMFocus    as ICCCMFocus
import qualified XMonad.Hooks.ManageDocks   as ManageDocks
import qualified XMonad.Hooks.ManageHelpers as HMH
import qualified XMonad.Hooks.Place         as HP
import qualified XMonad.Hooks.SetWMName     as HWMN
import qualified XMonad.Hooks.UrgencyHook   as HU

import qualified XMonad.Layout.Decoration            as LD
import qualified XMonad.Layout.MultiToggle           as LMT
import qualified XMonad.Layout.MultiToggle.Instances as LMTI
import qualified XMonad.Layout.NoBorders             as LNB
import qualified XMonad.Layout.PerWorkspace          as LPW
import qualified XMonad.Layout.Reflect               as LR
import qualified XMonad.Layout.Tabbed                as LT
import qualified XMonad.Layout.WorkspaceDir          as LWD

import qualified XMonad.ManageHook as MH

import qualified XMonad.Prompt           as P
import qualified XMonad.Prompt.Man       as PM
import qualified XMonad.Prompt.Ssh       as PS
import qualified XMonad.Prompt.Workspace as PW

import qualified XMonad.StackSet as SS

import qualified XMonad.Util.NamedScratchpad as SP
import qualified XMonad.Util.Run as R
import qualified XMonad.Util.EZConfig as EZ

-- TODO import qualified System.Taffybar.Hooks.PagerHints as TB

-- ────────────────────────────────────────────────────────────────────────────┘


-- ───────────────────────────────────────────────────────────── xconfig •2• ──┐

main = do myStatusBarHandle <- R.spawnPipe statusBarCmd
          xmonad $ HU.withUrgencyHook HU.NoUrgencyHook
                 $ EWMH.ewmh
                 -- TODO $ TB.pagerHints
                 $ xConfig myStatusBarHandle
  where
    xConfig myStatusBarHandle = XM.defaultConfig
      { XMonad.layoutHook         = myLayoutHook
      , XMonad.manageHook         = myManageHook
      , XMonad.handleEventHook    = myHandleEventHook
      , XMonad.logHook            = myLogHook myStatusBarHandle
      , XMonad.startupHook        = myStartupHook
      , XMonad.workspaces         = myWorkspaces
      , XMonad.modMask            = metaMask
      , XMonad.focusFollowsMouse  = shouldFocusFollowMouse
      , XMonad.clickJustFocuses   = shouldClickJustFocus
      , XMonad.borderWidth        = windowBorderWidth
      , XMonad.normalBorderColor  = toHex normalWindowBorderColor
      , XMonad.focusedBorderColor = toHex focusedWindowBorderColor
      , XMonad.terminal           = myTerminal
      , XMonad.keys               = keymapConfig
      , XMonad.mouseBindings      = mousemapConfig
      }

    mousemapConfig = \conf@(XM.XConfig {XMonad.modMask = modMask}) -> M.fromList
      [ (key, action)
      | (key, action, desc) <- mouseMaps
      ]
    keymapConfig = \conf@(XM.XConfig {XMonad.modMask = modMask}) -> M.fromList
      [ (key, action)
      | (key, action, _) <- keymaps
      ]

-- ────────────────────────────────────────────────────────── layouts •2.01• ──┤

myLayoutHook = LNB.smartBorders . ManageDocks.avoidStruts
             $ LWD.workspaceDir workspaceDir
             $ LMT.mkToggle1 LMTI.NBFULL    -- switch to full with no borders
             $ LMT.mkToggle1 LR.REFLECTX    -- reflect x-axis
             $ LMT.mkToggle1 LR.REFLECTY    -- reflect y-axis
             $ LMT.mkToggle1 LMTI.NOBORDERS -- remove borders
             $ LMT.mkToggle1 LMTI.MIRROR    -- mirror the current layout
             $ LPW.onWorkspace (myWorkspaces !! 0) myRefLayouts
             $ LPW.onWorkspace (myWorkspaces !! 1) myWflowLayouts
             $ LPW.onWorkspace (myWorkspaces !! 2) myWflowLayouts
             $ LPW.onWorkspace (myWorkspaces !! 3) myWflowsuppLayouts
             $ LPW.onWorkspace (myWorkspaces !! 4) myOrgLayouts
             $ LPW.onWorkspace (myWorkspaces !! 5) mySocialLayouts
             $ LPW.onWorkspace (myWorkspaces !! 6) myPlayLayouts
             $ LPW.onWorkspace (myWorkspaces !! 7) myMgmtLayouts
             $ LPW.onWorkspace (myWorkspaces !! 8) myTmpLayouts
             $ LPW.onWorkspace (myWorkspaces !! 9) myComboLayouts
             $ myDefaultLayouts
  where
    workspaceDir = "<%= File.expand_path local!(:workspace_dir) %>"

    -- Layout groups
    tabbedLayout = LT.tabbed LT.shrinkText $ LT.defaultTheme
                 { LT.inactiveBorderColor = toHex normalWindowBorderColor
                 , LT.activeBorderColor   = toHex focusedWindowBorderColor
                 , LT.activeTextColor     = toHex focusedWindowTextColor
                 , LT.urgentBorderColor   = toHex urgentBorderColor
                 , LT.urgentTextColor     = toHex urgentTextColor
                 }
    -- TODO: decide
    myRefLayouts       = tabbedLayout ||| myGridLayout
    myWflowLayouts     = myOneBigLayout ||| myMosaicLayout ||| myGridLayout ||| tabbedLayout
    myWflowsuppLayouts = tabbedLayout ||| myGridLayout ||| myOneBigLayout ||| myMosaicLayout
    myOrgLayouts       = tabbedLayout ||| myGridLayout
    mySocialLayouts    = tabbedLayout ||| myGridLayout
    myPlayLayouts      = tabbedLayout ||| myGridLayout
    myMgmtLayouts      = myGridLayout ||| myOneBigLayout ||| tabbedLayout
    myTmpLayouts       = myGridLayout ||| tabbedLayout
    myComboLayouts     = tabbedLayout
    myDefaultLayouts   = myWflowLayouts

    -- Layout definitions
    myCrossLayout     = XM.Full -- TODO simpleCross
    myFullLayout      = XM.Full -- TODO Full
    myAccordionLayout = XM.Full -- TODO Accordion
    myGridLayout      = XM.Full -- TODO Grid
    mySpiralLayout    = XM.Full -- TODO spiral (1/2)
    myMosaicLayout    = XM.Full -- TODO mosaic 2 [3, 2]
    myFloatLayout     = XM.Full -- TODO simpleFloat
    myOneBigLayout    = XM.Full -- TODO OneBig 0.6 0.74

-- ─────────────────────────────────────────────────────── workspaces •2.02• ──┤

myWorkspaces = zipWith (++) workspaceIds
             $ map (sep ++) workspaceNames
  where
    workspaceIds = [ (show workspaceIndex)  ++ delimiter
                   | workspaceIndex <- [1..]
                   ]
    delimiter = "•"
    sep = ""
    workspaceNames = [ "ref"
                     , "wf"
                     , "wf"
                     , "wfs"
                     , "org"
                     , "social"
                     , "play"
                     , "mgmt"
                     , "tmp"
                     , "combo"
                     ]

-- ───────────────────────────────────────────────────────── log hook •2.03• ──┤

myLogHook h = do copies <- CopyWindow.wsContainingCopies
                 ICCCMFocus.takeTopFocus
                 DynLog.dynamicLogWithPP (statusPP h copies)
                 UpdatePointer.updatePointer (0.5, 0.5) (0, 0)

statusBarCmd = "/usr/bin/xmobar"

statusPP h copies = DynLog.defaultPP
                  { DynLog.ppCurrent         = format currentColor currentSymbols
                  , DynLog.ppVisible         = format visibleColor visibleSymbols
                  , DynLog.ppHidden          = formatHidden copies
                  , DynLog.ppHiddenNoWindows = format emptyColor   emptySymbols
                  , DynLog.ppUrgent          = format urgentColor  urgentSymbols
                  , DynLog.ppLayout          = format layoutColor  layoutSymbols
                                          . take 16 -- maximum layout name (TODO to be computed automatically)
                                          . (++ repeat ' ')
                  , DynLog.ppSep    = "  "
                  , DynLog.ppWsSep  = " "
                  , DynLog.ppTitle  = take 0
                  , DynLog.ppOutput = R.hPutStrLn h
                  }
  where
    formatHidden copies ws | (ws `elem` copies) = format hiddenWithCopiesColor hiddenSymbols ws
                           | otherwise          = format hiddenColor           hiddenSymbols ws
    -- utility function: surround with symbols and apply colors
    format colorSpec symbolSpec = uncurry DynLog.xmobarColor (mapT toHex colorSpec)
                                . uncurry DynLog.wrap symbolSpec

    currentColor   = (bgColor, green colors)
    currentSymbols = (" ◄ ", " ► ")

    visibleColor   = (bgColor, orange colors)
    visibleSymbols = (" |", "| ")

    hiddenWithCopiesColor = (bgColor, yellow colors)
    hiddenColor           = (bgColor, cyan colors)
    hiddenSymbols         = (" ⟨ ", " ⟩ ")

    emptyColor   = (bgColor, grey colors)
    emptySymbols = (" ∅ ", " ∅ ")

    urgentColor   = (bgColor, red colors)
    urgentSymbols = (" ! ", " ! ")

    layoutColor   = (bgColor, magenta colors)
    layoutSymbols = (" λ ", " λ ")

-- ───────────────────────────────────────────────────── startup hook •2.05• ──┤

myStartupHook = EWMH.ewmhDesktopsStartup >> HWMN.setWMName "LG3D"

-- ──────────────────────────────────────────────── handle event hook •2.06• ──┤

myHandleEventHook =  XM.handleEventHook XM.defaultConfig
                 <+> ManageDocks.docksEventHook
                 <+> EWMH.ewmhDesktopsEventHook
                 <+> EWMH.fullscreenEventHook

-- ────────────────────────────────────────────────────── manage hook •2.07• ──┤

myManageHook =  HP.placeHook floatingWindowPlacement
            <+> basicManageHook
            <+> XM.manageHook XM.defaultConfig

floatingWindowPlacement = HP.withGaps (16, 0, 16, 0)
                        $ HP.smart (0.5, 0.5)

basicManageHook = MH.composeAll . concat $
                [ [ManageDocks.manageDocks]
                , [SP.namedScratchpadManageHook scratchpads]
                , [HMH.isFullscreen --> applyFullFloat]
                , [HMH.isDialog --> applyFloat]
                , [checkXWindowQuery q --> applyFloat | q      <- floats]
                , [checkXWindowQuery q --> MH.doShift w  | (q, w) <- shifts]
                ]
  where
    applyFullFloat = HMH.doFullFloat
    applyFloat     = MH.doFloat

    floats = [ XWindowClass "Pavucontrol"
             , XWindowClass "copyq"
             , XWindowClass "Xmessage"
             , XWindowClass "TeamViewer.exe"
             , XWindowTitle "Save As..."
             ]

    shifts = [ (XWindowClass "Firefox",                   myWorkspaces !! 0)
             , (XWindowClass "chromium-browser-chromium", myWorkspaces !! 0)
             ]

-- ────────────────────────────────────────────────────── scratchpads •2.08• ──┤

scratchpadSize = SS.RationalRect (1 / 4) (1 / 4) (1 / 2) (1 / 2)

scratchpads = [ SP.NS "term" myTerminal (MH.title =? "term") size
              , SP.NS "top" (runCmd "htop") (MH.title =? "htop") size
              <% if has_feature? :python %>
              , SP.NS "ipython" (runCmd "ipython") (MH.title =? "ipython") size
              <% end %>
              <% if has_feature? :ruby %>
              , SP.NS "irb" (runCmd "irb") (MH.title =? "irb") size
              <% end %>
              <% if has_feature? :haskell %>
              , SP.NS "ghci" (runCmd "ghci") (MH.title =? "ghci") size
              <% end %>
              ]
  where
    runCmd cmd = "<%= local! :term_run_cmd %> " ++ cmd
    size = SP.customFloating scratchpadSize

-- ───────────────────────────────────────────────────── key bindings •2.09• ──┤

metaMask = mod4Mask
altMask   = mod1Mask

keymaps :: [((KeyMask, KeySym), X (), String)]
keymaps = [ -- window management: change XM.focus
            ( (metaMask, xK_Tab)
            , XM.windows SS.focusDown
            , "move XM.focus to the next window"
            )
          , ( (metaMask .|. shiftMask, xK_Tab)
            , XM.windows SS.focusUp
            , "move XM.focus to the previous window"
            )
          , ( (metaMask, xK_j)
            , XM.windows SS.focusDown
            , "move XM.focus to the next window"
            )
          , ( (metaMask, xK_k)
            , XM.windows SS.focusUp
            , "move XM.focus to the previous window"
            )
            -- window management: swap
          , ( (metaMask, xK_Return)
            , Promote.dwmpromote
            , "swap focused window with master window"
            )
          , ( (metaMask .|. shiftMask, xK_j)
            , XM.windows SS.swapDown
            , "swap focused window with next window"
            )
          , ( (metaMask .|. shiftMask, xK_k)
            , XM.windows SS.swapUp
            , "swap focused window with previous window"
            )
          , ( (metaMask .|. altMask .|. shiftMask, xK_j)
            , RotSlaves.rotSlavesUp
            , "rotate (up) the XM.windows in the current stack, excluding the master window"
            )
          , ( (metaMask .|. altMask .|. shiftMask, xK_k)
            , RotSlaves.rotSlavesDown
            , "rotate (down) the XM.windows in the current stack, excluding the master window"
            )
            -- window management: resize
          , ( (metaMask, xK_n)
            , XM.refresh
            , "resize viewed XM.windows to the correct size"
            )
          , ( (metaMask, xK_h)
            , XM.sendMessage XM.Shrink
            , "shrink the master area"
            )
          , ( (metaMask, xK_l)
            , XM.sendMessage XM.Expand
            , "expand the master area"
            )
            -- window management: cycle through workspaces
          , ( (metaMask .|. controlMask, xK_Tab)
            , CycleRecentWS.cycleRecentWS [xK_Alt_L] xK_Tab xK_grave
            , "cycle through most recent workspaces"
            )
            -- window management: float XM.windows support
          , ( (metaMask .|. altMask, xK_r)
            , HP.placeFocused floatingWindowPlacement
            , "manually reposition focused floating window"
            )
          , ( (metaMask, xK_t)
            , XM.withFocused $ XM.windows . SS.sink
            , "push window back into tiling"
            )
          , ( (metaMask, xK_Left)
            , XM.withFocused $ FloatSnap.snapMove FloatSnap.L Nothing
            , "snap focused window to left border"
            )
          , ( (metaMask, xK_Right)
            , XM.withFocused $ FloatSnap.snapMove FloatSnap.R Nothing
            , "snap focused window to right border"
            )
          , ( (metaMask, xK_Up)
            , XM.withFocused $ FloatSnap.snapMove FloatSnap.U Nothing
            , "snap focused window to top border"
            )
          , ( (metaMask, xK_Down)
            , XM.withFocused $ FloatSnap.snapMove FloatSnap.D Nothing
            , "snap focused window to bottom border"
            )
          , ( (metaMask .|. shiftMask, xK_Left)
            , XM.withFocused $ FloatSnap.snapShrink FloatSnap.R Nothing
            , "expand focused window filling up to the left border"
            )
          , ( (metaMask .|. shiftMask, xK_Right)
            , XM.withFocused $ FloatSnap.snapGrow FloatSnap.R Nothing
            , "expand focused window filling up to the right border"
            )
          , ( (metaMask .|. shiftMask, xK_Up)
            , XM.withFocused $ FloatSnap.snapShrink FloatSnap.D Nothing
            , "expand focused window filling up to the top border"
            )
          , ( (metaMask .|. shiftMask, xK_Down)
            , XM.withFocused $ FloatSnap.snapGrow FloatSnap.D Nothing
            , "expand focused window filling up to the bottom border"
            )
            -- window management: work with master/slave XM.windows
          , ( (metaMask, xK_m)
            , XM.windows SS.focusMaster
            , "move XM.focus to the master window"
            )
          , ( (metaMask, xK_comma)
            , XM.sendMessage (XM.IncMasterN 1)
            , "increment the number of XM.windows in the master area"
            )
          , ( (metaMask, xK_period)
            , XM.sendMessage (XM.IncMasterN (-1))
            , "deincrement the number of XM.windows in the master area"
            )
            -- layout
          , ( (metaMask, xK_space)
            , XM.sendMessage XM.NextLayout
            , "rotate through the available layout algorithms"
            )
        -- TODO doesn't work
        --  , ( (metaMask .|. shiftMask, xK_space)
        --    , setLayout myLayoutHook
        --    , "reset the layouts on the current workspace to default"
        --    )
            -- launch
          , ( (metaMask .|. controlMask, xK_p)
            , xmonadCommands >>= Commands.runCommand
            , "run an internal xmonad command"
            )
          , ( (metaMask .|. shiftMask, xK_Return)
            , XM.spawn myTerminal
            , "open terminal"
            )
          , ( (metaMask, xK_p)
            , XM.spawn programLauncher
            , "open program launcher"
            )
          , ( (metaMask .|. shiftMask, xK_c)
            , CopyWindow.kill1
            , "close focused window (in the current workspace)"
            )
          , ( (metaMask .|. altMask .|. shiftMask, xK_c)
            , CopyWindow.killAllOtherCopies
            , "close all other copies of focused window"
            )
            -- scratchpads
          , ( (metaMask, xK_a)
            , Submap.submap . M.fromList $ [ (kb, action)
                                           | (kb, action, _) <- scratchpadsKeymaps]
            , "scratchpads"
            )
            -- search
          , ( (metaMask, xK_s)
            , Submap.submap $ M.fromList [ (kb, Search.promptSearch P.defaultXPConfig action)
                                         | (kb, action, _) <- searchKeymaps
                                         ]
            , "search prompt"
            )
          , ( (metaMask .|. shiftMask, xK_s)
            , Submap.submap $ M.fromList [ (kb, Search.selectSearch action)
                                         | (kb, action, _) <- searchKeymaps
                                         ]
            , "search from selection"
            )
            -- help
          , ( (metaMask .|. shiftMask, xK_slash)
            , XM.spawn $ xmessage help
            , "show available bindings"
            )
            -- quit / restart
          , ( (metaMask .|. shiftMask, xK_q)
            , XM.io $ exitWith ExitSuccess
            , "quit xmonad"
            )
          , ( (metaMask, xK_q)
            , XM.spawn recompileXMonad
            , "restart xmonad"
            )
          ]
          ++ -- switch/move window to previous/next screen
          [ ( (metaMask, xK_w)
            , PhyScreens.onPrevNeighbour SS.view
            , "switch to previous screen"
            )
          , ( (metaMask, xK_e)
            , PhyScreens.onNextNeighbour SS.view
            , "switch to next screen"
            )
          , ( (metaMask .|. shiftMask, xK_w)
            , PhyScreens.onPrevNeighbour SS.shift
            , "move focused window to previous screen"
            )
          , ( (metaMask .|. shiftMask, xK_e)
            , PhyScreens.onNextNeighbour SS.shift
            , "move focused window to next screen"
            )
          ]
          ++ -- switch screens
          [ ( (metaMask .|. altMask, key)
            , PhyScreens.viewScreen screenNum
            , "switch to screen nr." ++ show screenNum
            )
          | (key, screenNum) <- zip ([xK_1 .. xK_9] ++ [xK_0]) [0..]
          ]
          ++ -- move focused window to another screen
          [ ( (metaMask .|. altMask .|. shiftMask, key)
            , PhyScreens.sendToScreen screenNum
            , "move focused window to screen nr." ++ show screenNum
            )
          | (key, screenNum) <- zip ([xK_1 .. xK_9] ++ [xK_0]) [0..]
          ]
          ++ -- switch workspaces
          [ ( (metaMask, key)
            , XM.windows $ SS.greedyView workspace
            , "switch to workspace '" ++ workspace ++ "'" ++ " (nr." ++ show num ++ ")"
            )
          | (workspace, key, num) <- zip3 myWorkspaces ([xK_1 .. xK_9] ++ [xK_0]) [1..]
          ]
          ++ -- move focused window to another workspace
          [ ( (metaMask .|. shiftMask, key)
            , XM.windows $ SS.shift workspace
            , "move focused window to workspace '" ++ workspace ++ "'" ++ " (nr." ++ show num ++ ")"
            )
          | (workspace, key, num) <- zip3 myWorkspaces ([xK_1 .. xK_9] ++ [xK_0]) [1..]
          ]
          ++ -- copy focused window to another workspace
          [ ( (metaMask .|. controlMask .|. shiftMask, key)
            , XM.windows $ CopyWindow.copy workspace
            , "copy focused window to workspace '" ++ workspace ++ "'" ++ " (nr." ++ show num ++ ")"
            )
          | (workspace, key, num) <- zip3 myWorkspaces ([xK_1 .. xK_9] ++ [xK_0]) [1..]
          ]
  where
    programLauncher = "dmenu_run"

    recompileXMonad = "if type xmonad; then xmonad --recompile && xmonad --restart; else xmessage xmonad not in \\$PATH: \"$PATH\"; fi"

help = L.intercalate "\n" (header ++ [ppKey ++ kdSep ++ ppDesc | (ppKey, ppDesc) <- ppKeymaps])
  where
    header = [ title
             , concat $ replicate (length title) [titleSep]
             , ""
             ]
    title = "xmonad keymaps"
    titleSep = '─'

    kdSep = " : "

    ppKeymaps = [ppKeymap keymap allKeys allDescs | keymap <- allKeymaps]

    allKeymaps = mergeKeymaps rootKeymaps subKeymaps
    allKeys    = [(key, level) | (key, _,    level) <- allKeymaps]
    allDescs   = [desc         | (_,   desc, _)     <- allKeymaps]

    rootKeymaps = [(key, desc, RootLevel) | (key, _, desc) <- keymaps]
    subKeymaps  = [ ( "scratchpads"
                    , [ (key, desc, NestedLevel 1)
                      | (key, _, desc) <- scratchpadsKeymaps ]
                    )
                  , ( "search methods"
                    , [ (key, desc, NestedLevel 1)
                      | (key, _, desc) <- searchKeymaps ]
                    )
                  ]

scratchpadsKeymaps = [ ( (0, xK_t)
                       , SP.namedScratchpadAction scratchpads "term"
                       , "terminal"
                       )
                     , ( (0, xK_i)
                       , SP.namedScratchpadAction scratchpads "top"
                       , "process info"
                       )
                       <% if has_feature? :python %>
                     , ( (0, xK_p)
                       , SP.namedScratchpadAction scratchpads "ipython"
                       , "python repl"
                       )
                       <% end %>
                       <% if has_feature? :ruby %>
                     , ( (0, xK_r)
                       , SP.namedScratchpadAction scratchpads "irb"
                       , "ruby repl"
                       )
                       <% end %>
                       <% if has_feature? :haskell %>
                     , ( (0, xK_h)
                       , SP.namedScratchpadAction scratchpads "ghci"
                       , "haskell repl"
                       )
                       <% end %>
                     ]

searchKeymaps = [ ( (0, xK_a)
                  , Search.alpha
                  , "wolfram alpha"
                  )
                , ( (0, xK_c)
                  , Search.codesearch
                  , "google code"
                  )
                , ( (0, xK_d)
                  , Search.dictionary
                  , "dictionary.com"
                  )
                , ( (0, xK_g)
                  , Search.google
                  , "google search"
                  )
                , ( (shiftMask, xK_h)
                  , Search.hackage
                  , "hackage"
                  )
                , ( (0, xK_h)
                  , Search.hoogle
                  , "hoogle"
                  )
                , ( (0, xK_i)
                  , Search.images
                  , "google images"
                  )
                , ( (0, xK_m)
                  , Search.maps
                  , "google maps"
                  )
                , ( (shiftMask, xK_m)
                  , Search.mathworld
                  , "mathworld"
                  )
                , ( (0, xK_s)
                  , Search.scholar
                  , "google scholar"
                  )
                , ( (0, xK_t)
                  , Search.thesaurus
                  , "thesaurus.com"
                  )
                , ( (shiftMask, xK_w)
                  , Search.wayback
                  , "wayback"
                  )
                , ( (0, xK_w)
                  , Search.wikipedia
                  , "wikipedia"
                  )
                , ( (0, xK_y)
                  , Search.youtube
                  , "youtube"
                  )
                , ( (0, xK_u)
                  , Search.multi
                  , "multi-search"
                  )
                ]

xmonadCommands :: X [(String, X ())]
xmonadCommands = Commands.defaultCommands

-- TODO
-- workspacePromptKeymap =
--  , ((0, xK_w), PW.workspacePrompt xpConfig (XM.windows . SS.greedyView))
--  , ("M-a M-w", PW.workspacePrompt xpConfig (XM.windows . SS.shift))
--  , ("M-a m",   PM.manPrompt  xpConfig)
--  , ("M-a d",   LWD.changeDir xpConfig)
--  , ("M-a s",   PS.sshPrompt  xpConfig)

-- ─────────────────────────────────────────────────── mouse bindings •2.10• ──┤

mouseMaps = [ ( (metaMask, button1)
              , \w -> XM.focus w
                   >> XM.mouseMoveWindow w
                   >> FloatSnap.ifClick (snap w)
              , "move window (snapping to borders)"
              )
            , ( (metaMask .|. altMask, button1)
              , \w -> XM.focus w
                   >> FlexM.mouseWindow FlexM.linear w
                   >> FloatSnap.ifClick (snap w)
              , "scale/reposition the window (dynamic behavior by mouse pos)"
              )
            , ( (metaMask .|. shiftMask, button1)
              , \w -> XM.focus w
                   >> XM.mouseMoveWindow w
                   >> FloatSnap.ifClick (expandOnMove w)
              , "move window (expanding to borders)"
              )
            , ( (metaMask, button3)
              , \w -> XM.focus w
                   >> FlexR.mouseResizeWindow w
                   >> FloatSnap.ifClick (expandOnResize w)
              , "resize window (expanding to borders)"
              )
            , ( (metaMask .|. altMask, button3)
              , \w -> XM.focus w
                   >> ConstrResize.mouseResizeWindow w True
              , "resize window (keeping aspect ratio)")
            ]
  where
    snap           w = FloatSnap.snapMagicMove                distance distance w
    expandOnMove   w = FloatSnap.snapMagicResize allBorders   distance distance w
    expandOnResize w = FloatSnap.snapMagicResize resizeCorner distance distance w

    allBorders   = [FloatSnap.L, FloatSnap.R, FloatSnap.U, FloatSnap.D]
    resizeCorner = [FloatSnap.R, FloatSnap.D]

    distance = (Just 128)

-- ───────────────────────────────────────────────────────────── misc •2.11• ──┤

myTerminal = "<%= local! :term_open_cmd %>"

-- whether XM.focus follows the mouse pointer
shouldFocusFollowMouse = True

-- whether a mouse click select the XM.focus or is just passed to the window
shouldClickJustFocus = True

-- ─────────────────────────────────────────────────────────── prompt •2.12• ──┤

xpConfig = P.defaultXPConfig
         { P.font        = toXft font
         , P.bgColor     = toHex bgColor
         , P.fgColor     = toHex fgColor
         , P.bgHLight    = toHex bgHighlightColor
         , P.fgHLight    = toHex fgHighlightColor
         , P.borderColor = toHex normalWindowBorderColor
         , P.position    = P.Top
         }

-- ─────────────────────────────────────────────────────────── colors •2.13• ──┤

colors = ColorPalette
       { <%= local!(:colorscheme).map do |name, hex|
           "#{name} = Hex \"#{hex}\""
         end.join(", ") %>
       }

normalWindowBorderColor = grey colors

focusedWindowBorderColor = darkBlue colors
focusedWindowTextColor   = cyan colors

urgentBorderColor = magenta colors
urgentTextColor   = lightMagenta colors

bgColor = darkerGrey colors
fgColor = lightGrey colors

bgHighlightColor = darkGrey colors
fgHighlightColor = lighterGrey colors

-- ──────────────────────────────────────────────────────────── fonts •2.14• ──┤

font = Font
     { name = "<%= local! :font_name %>"
     , size =  <%= local! :font_size %>
     }

-- ──────────────────────────────────────────────────────────── sizes •2.15• ──┤

windowBorderWidth = 1

-- ────────────────────────────────────────────────────────────────────────────┘


-- ──────────────────────────────────────────────────────────────── misc •3• ──┐

-- ────────────────────────────────────────────────────── misc - font •3.01• ──┤
data Font = Font
          { name :: String
          , size :: Int
          }

toXft (Font name size) = "xft:" ++ name ++ "-" ++ show size

-- ───────────────────────────────────────────────────── misc - color •3.01• ──┤

data MyColor = Hex String

toHex :: MyColor -> String
toHex (Hex hex) = hex

data ColorPalette = ColorPalette
                  { darkerGrey   :: MyColor
                  , darkGrey     :: MyColor
                  , grey         :: MyColor
                  , lightGrey    :: MyColor
                  , lighterGrey  :: MyColor
                  , darkRed      :: MyColor
                  , red          :: MyColor
                  , darkGreen    :: MyColor
                  , green        :: MyColor
                  , orange       :: MyColor
                  , yellow       :: MyColor
                  , blue         :: MyColor
                  , darkBlue     :: MyColor
                  , magenta      :: MyColor
                  , lightMagenta :: MyColor
                  , cyan         :: MyColor
                  , lightCyan    :: MyColor
                  }

-- ────────────────────────────────────────────────────── misc - xorg •3.03• ──┤

data XWindowQuery a = XWindowClass    a
                    | XWindowResource a
                    | XWindowTitle    a

checkXWindowQuery (XWindowClass    a) = XM.className =? a
checkXWindowQuery (XWindowTitle    a) = XM.title     =? a
checkXWindowQuery (XWindowResource a) = XM.resource  =? a

-- ─────────────────────────────────────────────────── misc - keymaps •3.04• ──┤

data KeymapLevel = RootLevel
                 | NestedLevel Int

-- merge sub-keymaps with root-keymaps
mergeKeymaps rootKeymaps subKeymaps = mergeKeymaps' [] rootKeymaps subKeymaps
  where
    mergeKeymaps' res []           _  = res
    mergeKeymaps' res rootKeymaps  [] = res ++ rootKeymaps
    mergeKeymaps' res (x@(_, rootKeymapDesc, _):xs) (y@(matchingDesc, subKeymaps):ys)
      | rootKeymapDesc == matchingDesc = mergeKeymaps' (res ++ [x] ++ subKeymaps) xs ys
      | otherwise                      = mergeKeymaps' (res ++ [x])               xs (y:ys)

-- pretty format a keymap and its descriptive text
ppKeymap (key, desc, level) allKeys allDesc = (ppKey allKeys key level, ppDesc allDesc desc)
  where
    formatKey key level = (prefix level) ++ (unkeyify key)
      where
        prefix RootLevel       = concat $ replicate 0 indentStr
        prefix (NestedLevel l) = concat $ replicate l indentStr
        indentStr = "  •  "

    ppKey allKeys key level = padStr (maxKeyLength allKeys) (formatKey key level)

    maxKeyLength allKeys = maxLength
                         $ map (\k@(key, level) -> formatKey key level) allKeys

    ppDesc allDesc desc   = padStr (maxDescLength allDesc) desc
    maxDescLength allDesc = maxLength allDesc

-- stringify a keymap
unkeyify :: (KeyMask, KeySym) -> String
unkeyify (m,s) = let dp "" = ""
                     dp p  = p ++ " + "
                 in dp (vmask m) ++ XM.keysymToString s

vmask :: KeyMask -> String
vmask msk = L.intercalate " + "
          $ reverse
          $ fst
          $ foldr vmask' ([], msk) masks
  where
    masks = map (\m -> (m, show m)) [0..toEnum (bitSize msk - 1)] ++
            [ (lockMask,    "lock")
            , (controlMask, "ctrl")
            , (shiftMask,   "shift")
            , (mod5Mask,    "mod5")
            , (mod4Mask,    "meta")
            , (mod3Mask,    "scrolllock")
            , (mod2Mask,    "numlock")
            , (mod1Mask,    "alt")
            ]
    vmask'   _    a@( _, 0)                = a
    vmask' (m, s)   (ss, v) | v .&. m == m = (s:ss, v .&. complement m)
    vmask'   _         r                   = r

-- ───────────────────────────────────────────── misc - utils - tuple •3.05• ──┤

mapT :: (a -> b) -> (a, a) -> (b, b)
mapT f (a1, a2) = (f a1, f a2)

-- ────────────────────────────────────────────── misc - utils - list •3.06• ──┤

maxLength a = maximum $ map length a

-- ──────────────────────────────────────────── misc - utils - string •3.07• ──┤

padStr :: Int -> String -> String
padStr n s
  | length s < n = s ++ replicate (n - length s) ' '
  | otherwise    = s

-- ────────────────────────────────────────────────── misc - xmessage •3.08• ──┤

xmessage msg = "echo \"" ++ msg ++ "\" | xmessage -file -"

-- ────────────────────────────────────────────────────────────────────────────┘


-- vim: set filetype=eruby.haskell :
