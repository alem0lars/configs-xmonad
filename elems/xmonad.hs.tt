-- ────────────────────────────────────────────────────────────────────────────┐
--                                                                             │
-- Name:    elems/xmonad.hs.tt                                                 │
-- Summary: XMonad configuration.                                              │
-- Authors:                                                                    │
--   - Alessandro Molari <molari.alessandro@gmail.com> (alem0lars)             │
--                                                                             │
-- Project:                                                                    │
--   - Homepage:        https://github.com/alem0lars/configs-xmonad            │
--   - Getting started: see README.md in the project root folder               │
--                                                                             │
-- License: Apache v2.0 (see below)                                            │
--                                                                             │
-- ────────────────────────────────────────────────────────────────────────────┤
--                                                                             │
-- Licensed to the Apache Software Foundation (ASF) under one more contributor │
-- license agreements.  See the NOTICE file distributed with this work for     │
-- additional information regarding copyright ownership. The ASF licenses this │
-- file to you under the Apache License, Version 2.0 (the "License"); you may  │
-- not use this file except in compliance with the License.                    │
-- You may obtain a copy of the License at                                     │
--                                                                             │
--   http://www.apache.org/licenses/LICENSE-2.0                                │
--                                                                             │
-- Unless required by applicable law or agreed to in writing, software         │
-- distributed under the License is distributed on an "AS IS" BASIS, WITHOUT   │
-- WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.            │
-- See the License for the specific language governing permissions and         │
-- limitations under the License.                                              │
--                                                                             │
-- ────────────────────────────────────────────────────────────────────────────┤
<% define_locals do
  prefixed(:"xmonad.", as: nil) do
    variable :"terminal.open_cmd", as: :term_open_cmd
    variable :"terminal.run_cmd",  as: :term_run_cmd

    variable :workspace_dir

    variable :"font.name", as: :font_name
    variable :"font.size", as: :font_size, type: :int

    variable(:colorscheme) do |colorscheme|
      Hash[colorscheme.map { |name, hex| [name.camelize, hex] }]
    end
  end
end %>
-- ────────────────────────────────────────────────────────────────────────────┘


-- ┌───────────────────────────────────────────────────────────────────────────┐
-- │                            TABLE OF CONTENTS                              │
-- ├┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┤
-- │                                                                           │
-- │ ┌──→ •1• imports                                                          │
-- │ │                                                                         │
-- │ ├──→ •2• xconfig                                                          │
-- │ │     │                                                                   │
-- │ │     ├─→ •2.01• layouts                                                  │
-- │ │     ├─→ •2.02• workspaces                                               │
-- │ │     ├─→ •2.03• log hook                                                 │
-- │ │     ├─→ •2.04• statusbar                                                │
-- │ │     ├─→ •2.05• startup hook                                             │
-- │ │     ├─→ •2.06• handle event hook                                        │
-- │ │     ├─→ •2.07• manage hook                                              │
-- │ │     ├─→ •2.08• scratchpads                                              │
-- │ │     ├─→ •2.09• key bindings                                             │
-- │ │     ├─→ •2.10• mouse bindings                                           │
-- │ │     ├─→ •2.11• misc                                                     │
-- │ │     ├─→ •2.12• prompt                                                   │
-- │ │     ├─→ •2.13• colors                                                   │
-- │ │     ├─→ •2.14• fonts                                                    │
-- │ │     └─→ •2.15• sizes                                                    │
-- │ │                                                                         │
-- │ └──→ •3• types                                                            │
-- │                                                                           │
-- └───────────────────────────────────────────────────────────────────────────┘


-- ───────────────────────────────────────────────────────────── imports •1• ──┐

import System.Exit (ExitCode(ExitSuccess), exitWith)

import Data.Bits ((.&.), bitSize, complement)

import GHC.IO.Handle.Types (Handle)

import qualified Data.Monoid as Monoid
import qualified Data.Map    as Map
import qualified Data.List   as List

import XMonad ( xmonad
              , X
              , (|||)
              , (.|.)
              , (<+>)
              , (-->)
              , (=?)
              , KeyMask, KeySym, Button                     -- keymap data types
              , xK_a, xK_b, xK_c, xK_d, xK_e, xK_f    -- alphanumeric keys (1/5)
              , xK_g, xK_h, xK_i, xK_j, xK_k, xK_l    -- alphanumeric keys (2/5)
              , xK_m, xK_n, xK_o, xK_p, xK_q, xK_r    -- alphanumeric keys (3/5)
              , xK_s, xK_t, xK_u, xK_v, xK_w, xK_x    -- alphanumeric keys (4/5)
              , xK_y, xK_z                            -- alphanumeric keys (5/5)
              , xK_1, xK_2, xK_3, xK_4, xK_5, xK_6         -- numeric keys (1/2)
              , xK_7, xK_8, xK_9, xK_0                     -- numeric keys (2/2)
              , xK_Tab, xK_Return, xK_grave, xK_comma        -- other keys (1/2)
              , xK_space, xK_period, xK_slash, xK_Alt_L      -- other keys (2/2)
              , xK_Left, xK_Right, xK_Up, xK_Down                      -- arrows
              , mod1Mask, mod2Mask, mod3Mask, mod4Mask, mod5Mask  -- masks (1/2)
              , shiftMask, controlMask, lockMask                  -- masks (2/2)
              , button1, button2, button3                             -- buttons
              )
import qualified XMonad.Core as XMonad
import qualified XMonad      as XM

import qualified XMonad.Actions.UpdatePointer      as UpdatePointer
import qualified XMonad.Actions.DwmPromote         as Promote
import qualified XMonad.Actions.CycleRecentWS      as CycleRecentWS
import qualified XMonad.Actions.Commands           as Commands
import qualified XMonad.Actions.CopyWindow         as CopyWindow
import qualified XMonad.Actions.ConstrainedResize  as ConstrResize
import qualified XMonad.Actions.FloatSnap          as FloatSnap
import qualified XMonad.Actions.PhysicalScreens    as PhyScreens
import qualified XMonad.Actions.Search             as Search
import qualified XMonad.Actions.Submap             as Submap
import qualified XMonad.Actions.FlexibleManipulate as FlexM
import qualified XMonad.Actions.FlexibleResize     as FlexR
import qualified XMonad.Actions.RotSlaves          as RotSlaves
import qualified XMonad.Actions.FocusNth           as FocusNth

import qualified XMonad.Hooks.DynamicLog    as DynLog
import qualified XMonad.Hooks.EwmhDesktops  as EWMH
import qualified XMonad.Hooks.ICCCMFocus    as ICCCMFocus
import qualified XMonad.Hooks.ManageDocks   as ManageDocks
import qualified XMonad.Hooks.ManageHelpers as ManageHelpers
import qualified XMonad.Hooks.Place         as Place
import qualified XMonad.Hooks.SetWMName     as SetWMName
import qualified XMonad.Hooks.UrgencyHook   as UrgencyHook

import qualified XMonad.Layout.Decoration            as LD
import qualified XMonad.Layout.MultiToggle           as LMT
import qualified XMonad.Layout.MultiToggle.Instances as LMTI
import qualified XMonad.Layout.NoBorders             as LNB
import qualified XMonad.Layout.PerWorkspace          as LPW
import qualified XMonad.Layout.Reflect               as LR
import qualified XMonad.Layout.Tabbed                as LT
import qualified XMonad.Layout.WorkspaceDir          as LWD

import qualified XMonad.ManageHook as ManageHook

import qualified XMonad.Prompt as Prompt

import qualified XMonad.StackSet as StackSet

import qualified XMonad.Util.NamedScratchpad as Scratchpad
import qualified XMonad.Util.Run             as Run

-- TODO import qualified System.Taffybar.Hooks.PagerHints as TB

-- ────────────────────────────────────────────────────────────────────────────┘


-- ───────────────────────────────────────────────────────────── xconfig •2• ──┐

main :: IO ()
main  = do myStatusBarHandle <- Run.spawnPipe statusBarCmd
           xmonad $ UrgencyHook.withUrgencyHook UrgencyHook.NoUrgencyHook
                  $ EWMH.ewmh
                  -- TODO $ TB.pagerHints
                  $ xConfig myStatusBarHandle
  where
    xConfig myStatusBarHandle = XM.defaultConfig
      { XMonad.layoutHook         = layoutHook
      , XMonad.manageHook         = manageHook
      , XMonad.handleEventHook    = handleEventHook
      , XMonad.logHook            = logHook myStatusBarHandle
      , XMonad.startupHook        = startupHook
      , XMonad.workspaces         = workspaces
      , XMonad.modMask            = metaMask
      , XMonad.focusFollowsMouse  = shouldFocusFollowMouse
      , XMonad.clickJustFocuses   = shouldClickJustFocus
      , XMonad.borderWidth        = windowBorderWidth
      , XMonad.normalBorderColor  = toHex normalWindowBorderColor
      , XMonad.focusedBorderColor = toHex focusedWindowBorderColor
      , XMonad.terminal           = terminal
      , XMonad.keys               = keymapConfig
      , XMonad.mouseBindings      = mousemapConfig
      }

    mousemapConfig = \conf@(XM.XConfig {XMonad.modMask = modMask})
                  -> Map.fromList [ (key, action)
                                  | (key, action, desc) <- mouseMaps
                                  ]

    keymapConfig = \conf@(XM.XConfig {XMonad.modMask = modMask})
                -> Map.fromList [ (key, action)
                                | (key, action, _) <- keymaps
                                ]

-- ────────────────────────────────────────────────────────── layouts •2.01• ──┤

-- type is not specified because it is fucking hell (check `:t layoutHook`)
-- luckly haskell has powerful type inference :D
layoutHook = LNB.smartBorders . ManageDocks.avoidStruts
           $ LWD.workspaceDir workspaceDir
           $ LMT.mkToggle1 LMTI.NBFULL    -- switch to full with no borders
           $ LMT.mkToggle1 LR.REFLECTX    -- reflect x-axis
           $ LMT.mkToggle1 LR.REFLECTY    -- reflect y-axis
           $ LMT.mkToggle1 LMTI.NOBORDERS -- remove borders
           $ LMT.mkToggle1 LMTI.MIRROR    -- mirror the current layout
           $ LPW.onWorkspace (workspaces !! 0) myRefLayouts
           $ LPW.onWorkspace (workspaces !! 1) myWflowLayouts
           $ LPW.onWorkspace (workspaces !! 2) myWflowLayouts
           $ LPW.onWorkspace (workspaces !! 3) myWflowsuppLayouts
           $ LPW.onWorkspace (workspaces !! 4) myOrgLayouts
           $ LPW.onWorkspace (workspaces !! 5) mySocialLayouts
           $ LPW.onWorkspace (workspaces !! 6) myPlayLayouts
           $ LPW.onWorkspace (workspaces !! 7) myMgmtLayouts
           $ LPW.onWorkspace (workspaces !! 8) myTmpLayouts
           $ LPW.onWorkspace (workspaces !! 9) myComboLayouts
           $ myDefaultLayouts
  where
    workspaceDir = "<%= File.expand_path local!(:workspace_dir) %>"

    -- Layout groups
    tabbedLayout = LT.tabbed LT.shrinkText $ LT.defaultTheme
                 { LT.inactiveBorderColor = toHex normalWindowBorderColor
                 , LT.activeBorderColor   = toHex focusedWindowBorderColor
                 , LT.activeTextColor     = toHex focusedWindowTextColor
                 , LT.urgentBorderColor   = toHex urgentBorderColor
                 , LT.urgentTextColor     = toHex urgentTextColor
                 }
    -- TODO: decide
    myRefLayouts       = tabbedLayout ||| myGridLayout
    myWflowLayouts     = myOneBigLayout ||| myMosaicLayout ||| myGridLayout ||| tabbedLayout
    myWflowsuppLayouts = tabbedLayout ||| myGridLayout ||| myOneBigLayout ||| myMosaicLayout
    myOrgLayouts       = tabbedLayout ||| myGridLayout
    mySocialLayouts    = tabbedLayout ||| myGridLayout
    myPlayLayouts      = tabbedLayout ||| myGridLayout
    myMgmtLayouts      = myGridLayout ||| myOneBigLayout ||| tabbedLayout
    myTmpLayouts       = myGridLayout ||| tabbedLayout
    myComboLayouts     = tabbedLayout
    myDefaultLayouts   = myWflowLayouts

    -- Layout definitions
    myCrossLayout     = XM.Full -- TODO simpleCross
    myFullLayout      = XM.Full -- TODO Full
    myAccordionLayout = XM.Full -- TODO Accordion
    myGridLayout      = XM.Full -- TODO Grid
    mySpiralLayout    = XM.Full -- TODO spiral (1/2)
    myMosaicLayout    = XM.Full -- TODO mosaic 2 [3, 2]
    myFloatLayout     = XM.Full -- TODO simpleFloat
    myOneBigLayout    = XM.Full -- TODO OneBig 0.6 0.74

-- ─────────────────────────────────────────────────────── workspaces •2.02• ──┤

workspaces :: [String]
workspaces  = zipWith (++) workspaceIds
            $ map (sep ++) workspaceNames
  where
    delimiter = "•"
    sep = ""

    workspaceIds = [ (show workspaceIndex)  ++ delimiter
                   | workspaceIndex <- [1..]
                   ]

    workspaceNames = [ "ref"
                     , "wf"
                     , "wf"
                     , "wfs"
                     , "org"
                     , "social"
                     , "play"
                     , "mgmt"
                     , "tmp"
                     , "combo"
                     ]

-- ───────────────────────────────────────────────────────── log hook •2.03• ──┤

logHook :: Handle
        -> X ()

logHook h = do copies <- CopyWindow.wsContainingCopies
               ICCCMFocus.takeTopFocus
               DynLog.dynamicLogWithPP (statusPP h copies)
               UpdatePointer.updatePointer (0.5, 0.5) (0, 0)

statusBarCmd :: String
statusBarCmd  = "/usr/bin/xmobar"

statusPP :: Foldable t
         => Handle
         -> t String
         -> DynLog.PP

statusPP h copies = DynLog.defaultPP
                  { DynLog.ppCurrent         = format currentColor currentSymbols
                  , DynLog.ppVisible         = format visibleColor visibleSymbols
                  , DynLog.ppHidden          = formatHidden copies
                  , DynLog.ppHiddenNoWindows = format emptyColor   emptySymbols
                  , DynLog.ppUrgent          = format urgentColor  urgentSymbols
                  , DynLog.ppLayout          = format layoutColor  layoutSymbols
                                             . take 16 -- maximum layout name (TODO to be computed automatically)
                                          . (++ repeat ' ')
                  , DynLog.ppSep    = "  "
                  , DynLog.ppWsSep  = " "
                  , DynLog.ppTitle  = take 0
                  , DynLog.ppOutput = Run.hPutStrLn h
                  }
  where
    formatHidden copies ws | (ws `elem` copies) = format hiddenWithCopiesColor hiddenSymbols ws
                           | otherwise          = format hiddenColor           hiddenSymbols ws
    -- utility function: surround with symbols and apply colors
    format colorSpec symbolSpec = uncurry DynLog.xmobarColor (mapT toHex colorSpec)
                                . uncurry DynLog.wrap symbolSpec

    currentColor   = (bgColor, green colors)
    currentSymbols = (" ◄ ", " ► ")

    visibleColor   = (bgColor, orange colors)
    visibleSymbols = (" |", "| ")

    hiddenWithCopiesColor = (bgColor, yellow colors)
    hiddenColor           = (bgColor, cyan colors)
    hiddenSymbols         = (" ⟨ ", " ⟩ ")

    emptyColor   = (bgColor, grey colors)
    emptySymbols = (" ∅ ", " ∅ ")

    urgentColor   = (bgColor, red colors)
    urgentSymbols = (" ! ", " ! ")

    layoutColor   = (bgColor, magenta colors)
    layoutSymbols = (" λ ", " λ ")

-- ───────────────────────────────────────────────────── startup hook •2.05• ──┤

startupHook :: X ()
startupHook  = do EWMH.ewmhDesktopsStartup
                  SetWMName.setWMName "LG3D"

-- ──────────────────────────────────────────────── handle event hook •2.06• ──┤

handleEventHook :: XM.Event
                -> X Monoid.All

handleEventHook =  XM.handleEventHook XM.defaultConfig
               <+> ManageDocks.docksEventHook
               <+> EWMH.ewmhDesktopsEventHook
               <+> EWMH.fullscreenEventHook

-- ────────────────────────────────────────────────────── manage hook •2.07• ──┤

manageHook ::  XM.ManageHook
manageHook  =  Place.placeHook floatingWindowPlacement
           <+> basicManageHook
           <+> XM.manageHook XM.defaultConfig

floatingWindowPlacement :: Place.Placement
floatingWindowPlacement  = Place.withGaps (16, 0, 16, 0)
                         $ Place.smart (0.5, 0.5)

basicManageHook :: XM.ManageHook
basicManageHook  = XM.composeAll . concat $
                 [ [ManageDocks.manageDocks]
                 , [Scratchpad.namedScratchpadManageHook scratchpads]
                 , [ManageHelpers.isFullscreen --> ManageHelpers.doFullFloat]
                 , [ManageHelpers.isDialog     --> ManageHook.doFloat]
                 , [ checkXWindowQuery q --> ManageHook.doFloat
                   | q <- floats
                   ]
                 , [ checkXWindowQuery q --> ManageHook.doShift w
                   | (q, w) <- shifts
                   ]
                 ]
  where
    floats = [ XWindowClass "Pavucontrol"
             , XWindowClass "copyq"
             , XWindowClass "Xmessage"
             , XWindowClass "TeamViewer.exe"
             , XWindowTitle "Save As..."
             ]

    shifts = [ (XWindowClass "Firefox",                   workspaces !! 0)
             , (XWindowClass "chromium-browser-chromium", workspaces !! 0)
             ]

-- ────────────────────────────────────────────────────── scratchpads •2.08• ──┤

scratchpadSize :: StackSet.RationalRect
scratchpadSize  = StackSet.RationalRect (1 / 4) (1 / 4) (1 / 2) (1 / 2)

scratchpads :: [Scratchpad.NamedScratchpad]
scratchpads  = [ Scratchpad.NS "term" terminal (ManageHook.title =? "term") size
               , Scratchpad.NS "top" (runCmd "htop") (ManageHook.title =? "htop") size
               <% if has_feature? :python %>
               , Scratchpad.NS "ipython" (runCmd "ipython") (ManageHook.title =? "ipython") size
               <% end %>
               <% if has_feature? :ruby %>
               , Scratchpad.NS "irb" (runCmd "irb") (ManageHook.title =? "irb") size
               <% end %>
               <% if has_feature? :haskell %>
               , Scratchpad.NS "ghci" (runCmd "ghci") (ManageHook.title =? "ghci") size
               <% end %>
               ]
  where
    runCmd cmd = "<%= local! :term_run_cmd %> " ++ cmd

    size = Scratchpad.customFloating scratchpadSize

-- ───────────────────────────────────────────────────── key bindings •2.09• ──┤

metaMask :: KeyMask
metaMask  = mod4Mask

altMask :: KeyMask
altMask  = mod1Mask

keymaps :: [((KeyMask, KeySym), X (), String)]
keymaps  = [ -- window management: change XM.focus
             ( (metaMask, xK_Tab)
             , XM.windows StackSet.focusDown
             , "move XM.focus to the next window"
             )
           , ( (metaMask .|. shiftMask, xK_Tab)
             , XM.windows StackSet.focusUp
             , "move XM.focus to the previous window"
             )
           , ( (metaMask, xK_j)
             , XM.windows StackSet.focusDown
             , "move XM.focus to the next window"
             )
           , ( (metaMask, xK_k)
             , XM.windows StackSet.focusUp
             , "move XM.focus to the previous window"
             )
             -- window management: swap
           , ( (metaMask, xK_Return)
             , Promote.dwmpromote
             , "swap focused window with master window"
             )
           , ( (metaMask .|. shiftMask, xK_j)
             , XM.windows StackSet.swapDown
             , "swap focused window with next window"
             )
           , ( (metaMask .|. shiftMask, xK_k)
             , XM.windows StackSet.swapUp
             , "swap focused window with previous window"
             )
           , ( (metaMask .|. altMask .|. shiftMask, xK_j)
             , RotSlaves.rotSlavesUp
             , "rotate (up) the XM.windows in the current stack, excluding the master window"
             )
           , ( (metaMask .|. altMask .|. shiftMask, xK_k)
             , RotSlaves.rotSlavesDown
             , "rotate (down) the XM.windows in the current stack, excluding the master window"
             )
             -- window management: resize
           , ( (metaMask, xK_n)
             , XM.refresh
             , "resize viewed XM.windows to the correct size"
             )
           , ( (metaMask, xK_h)
             , XM.sendMessage XM.Shrink
             , "shrink the master area"
             )
           , ( (metaMask, xK_l)
             , XM.sendMessage XM.Expand
             , "expand the master area"
             )
             -- window management: cycle through workspaces
           , ( (metaMask .|. controlMask, xK_Tab)
             , CycleRecentWS.cycleRecentWS [xK_Alt_L] xK_Tab xK_grave
             , "cycle through most recent workspaces"
             )
             -- window management: float XM.windows support
           , ( (metaMask .|. altMask, xK_r)
             , Place.placeFocused floatingWindowPlacement
             , "manually reposition focused floating window"
             )
           , ( (metaMask, xK_t)
             , XM.withFocused $ XM.windows . StackSet.sink
             , "push window back into tiling"
             )
           , ( (metaMask, xK_Left)
             , XM.withFocused $ FloatSnap.snapMove FloatSnap.L Nothing
             , "snap focused window to left border"
             )
           , ( (metaMask, xK_Right)
             , XM.withFocused $ FloatSnap.snapMove FloatSnap.R Nothing
             , "snap focused window to right border"
             )
           , ( (metaMask, xK_Up)
             , XM.withFocused $ FloatSnap.snapMove FloatSnap.U Nothing
             , "snap focused window to top border"
             )
           , ( (metaMask, xK_Down)
             , XM.withFocused $ FloatSnap.snapMove FloatSnap.D Nothing
             , "snap focused window to bottom border"
             )
           , ( (metaMask .|. shiftMask, xK_Left)
             , XM.withFocused $ FloatSnap.snapShrink FloatSnap.L Nothing
             , "expand focused window filling up to the left border"
             )
           , ( (metaMask .|. shiftMask, xK_Right)
             , XM.withFocused $ FloatSnap.snapGrow FloatSnap.R Nothing
             , "expand focused window filling up to the right border"
             )
           , ( (metaMask .|. shiftMask, xK_Up)
             , XM.withFocused $ FloatSnap.snapShrink FloatSnap.U Nothing
             , "expand focused window filling up to the top border"
             )
           , ( (metaMask .|. shiftMask, xK_Down)
             , XM.withFocused $ FloatSnap.snapGrow FloatSnap.D Nothing
             , "expand focused window filling up to the bottom border"
             )
             -- window management: work with master/slave XM.windows
           , ( (metaMask, xK_m)
             , XM.windows StackSet.focusMaster
             , "move XM.focus to the master window"
             )
           , ( (metaMask, xK_comma)
             , XM.sendMessage (XM.IncMasterN 1)
             , "increment the number of XM.windows in the master area"
             )
           , ( (metaMask, xK_period)
             , XM.sendMessage (XM.IncMasterN (-1))
             , "deincrement the number of XM.windows in the master area"
             )
             -- layout
           , ( (metaMask, xK_space)
             , XM.sendMessage XM.NextLayout
             , "rotate through the available layout algorithms"
             )
         -- TODO doesn't work
         --  , ( (metaMask .|. shiftMask, xK_space)
         --    , setLayout layoutHook
         --    , "reset the layouts on the current workspace to default"
         --    )
             -- launch
           , ( (metaMask .|. controlMask, xK_p)
             , xmonadCommands >>= Commands.runCommand
             , "run an internal xmonad command"
             )
           , ( (metaMask .|. shiftMask, xK_Return)
             , XM.spawn terminal
             , "open terminal"
             )
           , ( (metaMask, xK_p)
             , XM.spawn programLauncher
             , "open program launcher"
             )
           , ( (metaMask .|. shiftMask, xK_c)
             , CopyWindow.kill1
             , "close focused window (in the current workspace)"
             )
           , ( (metaMask .|. altMask .|. shiftMask, xK_c)
             , CopyWindow.killAllOtherCopies
             , "close all other copies of focused window"
             )
             -- scratchpads
           , ( (metaMask, xK_a)
             , Submap.submap $ Map.fromList
                 [ (kb, action)
                 | (kb, action, _) <- scratchpadsKeymaps
                 ]
             , "scratchpads"
             )
             -- search
           , ( (metaMask, xK_s)
             , Submap.submap $ Map.fromList
                 [ (kb, Search.promptSearch Prompt.defaultXPConfig action)
                 | (kb, action, _) <- searchKeymaps
                 ]
             , "search prompt"
             )
           , ( (metaMask .|. shiftMask, xK_s)
             , Submap.submap $ Map.fromList
                 [ (kb, Search.selectSearch action)
                 | (kb, action, _) <- searchKeymaps
                 ]
             , "search from selection"
             )
             -- help
           , ( (metaMask .|. shiftMask, xK_slash)
             , XM.spawn $ xmessage help
             , "show available bindings"
             )
             -- quit / restart
           , ( (metaMask .|. shiftMask, xK_q)
             , XM.io $ exitWith ExitSuccess
             , "quit xmonad"
             )
           , ( (metaMask, xK_q)
             , XM.spawn recompileXMonad
             , "restart xmonad"
             )
           ]
           ++ -- switch/move window to previous/next screen
           [ ( (metaMask, xK_w)
             , PhyScreens.onPrevNeighbour StackSet.view
             , "switch to previous screen"
             )
           , ( (metaMask, xK_e)
             , PhyScreens.onNextNeighbour StackSet.view
             , "switch to next screen"
             )
           , ( (metaMask .|. shiftMask, xK_w)
             , PhyScreens.onPrevNeighbour StackSet.shift
             , "move focused window to previous screen"
             )
           , ( (metaMask .|. shiftMask, xK_e)
             , PhyScreens.onNextNeighbour StackSet.shift
             , "move focused window to next screen"
             )
           ]
           ++ -- switch screens
           [ ( (metaMask .|. altMask, key)
             , PhyScreens.viewScreen screenNum
             , "switch to screen nr." ++ show screenNum
             )
           | (key, screenNum) <- zip ([xK_1 .. xK_9] ++ [xK_0]) [0..]
           ]
           ++ -- move focused window to another screen
           [ ( (metaMask .|. altMask .|. shiftMask, key)
             , PhyScreens.sendToScreen screenNum
             , "move focused window to screen nr." ++ show screenNum
             )
           | (key, screenNum) <- zip ([xK_1 .. xK_9] ++ [xK_0]) [0..]
           ]
           ++ -- switch workspaces
           [ ( (metaMask, key)
             , XM.windows $ StackSet.greedyView workspace
             , "switch to workspace '" ++ workspace ++ "'" ++ " (nr." ++ show num ++ ")"
             )
           | (workspace, key, num) <- zip3 workspaces ([xK_1 .. xK_9] ++ [xK_0]) [1..]
           ]
           ++ -- move focused window to another workspace
           [ ( (metaMask .|. shiftMask, key)
             , XM.windows $ StackSet.shift workspace
             , "move focused window to workspace '" ++ workspace ++ "'" ++
               " (nr." ++ show num ++ ")"
             )
           | (workspace, key, num) <- zip3 workspaces ([xK_1 .. xK_9] ++ [xK_0]) [1..]
           ]
           ++ -- focus the nth window of the current workspace
           [ ( (metaMask .|. controlMask, key)
             , FocusNth.focusNth num
             , "focus the window nr." ++ show num ++ " of the current workspace"
             )
           | (key, num) <- zip ([xK_1 .. xK_9] ++ [xK_0]) [0..]
           ]
           ++ -- copy focused window to another workspace
           [ ( (metaMask .|. controlMask .|. shiftMask, key)
             , XM.windows $ CopyWindow.copy workspace
             , "copy focused window to workspace '" ++ workspace ++ "'" ++
               " (nr." ++ show num ++ ")"
             )
           | (workspace, key, num) <- zip3 workspaces ([xK_1 .. xK_9] ++ [xK_0]) [1..]
           ]
  where
    programLauncher = "dmenu_run"

    recompileXMonad = " if type xmonad; then"
                   ++ "   xmonad --recompile &&"
                   ++ "   xmonad --restart;"
                   ++ " else"
                   ++ "   xmessage xmonad not in \\$PATH: \"$PATH\";"
                   ++ " fi"

help :: String
help  = List.intercalate "\n" ( header
                                ++
                                [ ppKey ++ kdSep ++ ppDesc
                                | (ppKey, ppDesc) <- ppKeymaps
                                ]
                              )
  where
    header = [ title
             , concat $ replicate (length title) [titleSep]
             , ""
             ]
    title = "xmonad keymaps"
    titleSep = '─'

    kdSep = " : "

    ppKeymaps = [ppKeymap keymap allKeys allDescs | keymap <- allKeymaps]

    allKeymaps = mergeKeymaps rootKeymaps subKeymaps
    allKeys    = [(key, level) | (key, _,    level) <- allKeymaps]
    allDescs   = [desc         | (_,   desc, _)     <- allKeymaps]

    rootKeymaps = [(key, desc, RootLevel) | (key, _, desc) <- keymaps]
    subKeymaps  = [ ( "scratchpads"
                    , [ (key, desc, NestedLevel 1)
                      | (key, _, desc) <- scratchpadsKeymaps ]
                    )
                  , ( "search methods"
                    , [ (key, desc, NestedLevel 1)
                      | (key, _, desc) <- searchKeymaps ]
                    )
                  ]

scratchpadsKeymaps :: [((KeyMask, KeySym), X (), [Char])]
scratchpadsKeymaps  = [ ( (0, xK_t)
                        , Scratchpad.namedScratchpadAction scratchpads "term"
                        , "terminal"
                        )
                      , ( (0, xK_i)
                        , Scratchpad.namedScratchpadAction scratchpads "top"
                        , "process info"
                        )
                        <% if has_feature? :python %>
                      , ( (0, xK_p)
                        , Scratchpad.namedScratchpadAction scratchpads "ipython"
                        , "python repl"
                        )
                        <% end %>
                        <% if has_feature? :ruby %>
                      , ( (0, xK_r)
                        , Scratchpad.namedScratchpadAction scratchpads "irb"
                        , "ruby repl"
                        )
                        <% end %>
                        <% if has_feature? :haskell %>
                      , ( (0, xK_h)
                        , Scratchpad.namedScratchpadAction scratchpads "ghci"
                        , "haskell repl"
                        )
                        <% end %>
                      ]

searchKeymaps :: [((KeyMask, KeySym), Search.SearchEngine, [Char])]
searchKeymaps  = [ ( (0, xK_a)
                   , Search.alpha
                   , "wolfram alpha"
                   )
                 , ( (0, xK_c)
                   , Search.codesearch
                   , "google code"
                   )
                 , ( (0, xK_d)
                   , Search.dictionary
                   , "dictionary.com"
                   )
                 , ( (0, xK_g)
                   , Search.google
                   , "google search"
                   )
                 , ( (shiftMask, xK_h)
                   , Search.hackage
                   , "hackage"
                   )
                 , ( (0, xK_h)
                   , Search.hoogle
                   , "hoogle"
                   )
                 , ( (0, xK_i)
                   , Search.images
                   , "google images"
                   )
                 , ( (0, xK_m)
                   , Search.maps
                   , "google maps"
                   )
                 , ( (shiftMask, xK_m)
                   , Search.mathworld
                   , "mathworld"
                   )
                 , ( (0, xK_s)
                   , Search.scholar
                   , "google scholar"
                   )
                 , ( (0, xK_t)
                   , Search.thesaurus
                   , "thesaurus.com"
                   )
                 , ( (shiftMask, xK_w)
                   , Search.wayback
                   , "wayback"
                   )
                 , ( (0, xK_w)
                   , Search.wikipedia
                   , "wikipedia"
                   )
                 , ( (0, xK_y)
                   , Search.youtube
                   , "youtube"
                   )
                 , ( (0, xK_u)
                   , Search.multi
                   , "multi-search"
                   )
                 ]

xmonadCommands :: X [(String, X ())]
xmonadCommands  = Commands.defaultCommands

-- TODO
-- workspacePromptKeymap =
--  , ((0, xK_w), PW.workspacePrompt xpConfig (XM.windows . StackSet.greedyView))
--  , ("M-a M-w", PW.workspacePrompt xpConfig (XM.windows . StackSet.shift))
--  , ("M-a m",   PM.manPrompt  xpConfig)
--  , ("M-a d",   LWD.changeDir xpConfig)
--  , ("M-a s",   PS.sshPrompt  xpConfig)

-- ─────────────────────────────────────────────────── mouse bindings •2.10• ──┤

mouseMaps :: [((KeyMask, Button), XM.Window -> X (), [Char])]
mouseMaps  = [ ( (metaMask, button1)
               , \w -> XM.focus w
                    >> XM.mouseMoveWindow w
                    >> FloatSnap.ifClick (snap w)
               , "move window (snapping to borders)"
               )
             , ( (metaMask .|. altMask, button1)
               , \w -> XM.focus w
                    >> FlexM.mouseWindow FlexM.linear w
                    >> FloatSnap.ifClick (snap w)
               , "scale/reposition the window (dynamic behavior by mouse pos)"
               )
             , ( (metaMask .|. shiftMask, button1)
               , \w -> XM.focus w
                    >> XM.mouseMoveWindow w
                    >> FloatSnap.ifClick (expandOnMove w)
               , "move window (expanding to borders)"
               )
             , ( (metaMask, button3)
               , \w -> XM.focus w
                    >> FlexR.mouseResizeWindow w
                    >> FloatSnap.ifClick (expandOnResize w)
               , "resize window (expanding to borders)"
               )
             , ( (metaMask .|. altMask, button3)
               , \w -> XM.focus w
                    >> ConstrResize.mouseResizeWindow w True
               , "resize window (keeping aspect ratio)")
             ]
  where
    snap           w = FloatSnap.snapMagicMove                distance distance w
    expandOnMove   w = FloatSnap.snapMagicResize allBorders   distance distance w
    expandOnResize w = FloatSnap.snapMagicResize resizeCorner distance distance w

    allBorders   = [FloatSnap.L, FloatSnap.R, FloatSnap.U, FloatSnap.D]
    resizeCorner = [FloatSnap.R, FloatSnap.D]

    distance = (Just 128)

-- ───────────────────────────────────────────────────────────── misc •2.11• ──┤

terminal :: String
terminal  = "<%= local! :term_open_cmd %>"

-- whether XM.focus follows the mouse pointer
shouldFocusFollowMouse :: Bool
shouldFocusFollowMouse  = True

-- whether a mouse click select the XM.focus or is just passed to the window
shouldClickJustFocus :: Bool
shouldClickJustFocus  = True

-- ─────────────────────────────────────────────────────────── prompt •2.12• ──┤

xpConfig :: Prompt.XPConfig
xpConfig  = Prompt.defaultXPConfig
          { Prompt.font        = toXft font
          , Prompt.bgColor     = toHex bgColor
          , Prompt.fgColor     = toHex fgColor
          , Prompt.bgHLight    = toHex bgHighlightColor
          , Prompt.fgHLight    = toHex fgHighlightColor
          , Prompt.borderColor = toHex normalWindowBorderColor
          , Prompt.position    = Prompt.Top
          }

-- ─────────────────────────────────────────────────────────── colors •2.13• ──┤

colors :: ColorPalette
colors  = ColorPalette
        { <%= local!(:colorscheme).map do |name, hex|
            "#{name} = Hex \"#{hex}\""
          end.join(", ") %>
        }

normalWindowBorderColor :: Color
normalWindowBorderColor  = grey colors

focusedWindowBorderColor :: Color
focusedWindowBorderColor  = darkBlue colors

focusedWindowTextColor :: Color
focusedWindowTextColor  = cyan colors

urgentBorderColor :: Color
urgentBorderColor  = magenta colors

urgentTextColor :: Color
urgentTextColor  = lightMagenta colors

bgColor :: Color
bgColor = darkerGrey colors

fgColor :: Color
fgColor  = lightGrey colors

bgHighlightColor :: Color
bgHighlightColor  = darkGrey colors

fgHighlightColor :: Color
fgHighlightColor  = lighterGrey colors

-- ──────────────────────────────────────────────────────────── fonts •2.14• ──┤

font :: Font
font  = Font
      { name = "<%= local! :font_name %>"
      , size =  <%= local! :font_size %>
      }

-- ──────────────────────────────────────────────────────────── sizes •2.15• ──┤

windowBorderWidth :: XM.Dimension
windowBorderWidth  = 1

-- ────────────────────────────────────────────────────────────────────────────┘


-- ──────────────────────────────────────────────────────────────── misc •3• ──┐

-- ────────────────────────────────────────────────────── misc - font •3.01• ──┤

data Font = Font
          { name :: String
          , size :: Int
          }

toXft :: Font
      -> String

toXft (Font name size) = "xft:" ++ name ++ "-" ++ show size

-- ───────────────────────────────────────────────────── misc - color •3.01• ──┤

data Color = Hex String

toHex :: Color
      -> String

toHex (Hex hex) = hex

data ColorPalette = ColorPalette
                  { darkerGrey   :: Color
                  , darkGrey     :: Color
                  , grey         :: Color
                  , lightGrey    :: Color
                  , lighterGrey  :: Color
                  , darkRed      :: Color
                  , red          :: Color
                  , darkGreen    :: Color
                  , green        :: Color
                  , orange       :: Color
                  , yellow       :: Color
                  , blue         :: Color
                  , darkBlue     :: Color
                  , magenta      :: Color
                  , lightMagenta :: Color
                  , cyan         :: Color
                  , lightCyan    :: Color
                  }

-- ────────────────────────────────────────────────────── misc - xorg •3.03• ──┤

data XWindowQuery a = XWindowClass    a
                    | XWindowResource a
                    | XWindowTitle    a

checkXWindowQuery :: XWindowQuery String
                  -> XM.Query Bool

checkXWindowQuery (XWindowClass    a) = XM.className =? a
checkXWindowQuery (XWindowTitle    a) = XM.title     =? a
checkXWindowQuery (XWindowResource a) = XM.resource  =? a

-- ─────────────────────────────────────────────────── misc - keymaps •3.04• ──┤

data KeymapLevel = RootLevel
                 | NestedLevel Int

-- merge sub-keymaps with root-keymaps
mergeKeymaps :: Eq a
             => [(t, a, t1)]
             -> [(a, [(t, a, t1)])]
             -> [(t, a, t1)]

mergeKeymaps rootKeymaps subKeymaps = mergeKeymaps' [] rootKeymaps subKeymaps
  where
    mergeKeymaps' res []           _  = res
    mergeKeymaps' res rootKeymaps  [] = res ++ rootKeymaps
    mergeKeymaps' res (x@(_, rootKeymapDesc, _):xs) (y@(matchingDesc, subKeymaps):ys)
      | rootKeymapDesc == matchingDesc = mergeKeymaps' (res ++ [x] ++ subKeymaps) xs ys
      | otherwise                      = mergeKeymaps' (res ++ [x])               xs (y:ys)

-- pretty format a keymap and its descriptive text
ppKeymap :: Foldable t
         => ((KeyMask, KeySym), String, KeymapLevel)
         -> [((KeyMask, KeySym), KeymapLevel)]
         -> [t a]
         -> (String, String)

ppKeymap (key, desc, level) allKeys allDesc =
    ( ppKey  allKeys key level
    , ppDesc allDesc desc
    )
  where
    formatKey key level = (prefix level) ++ (unkeyify key)
      where
        prefix RootLevel       = concat $ replicate 0 indentStr
        prefix (NestedLevel l) = concat $ replicate l indentStr
        indentStr = "  •  "

    ppKey allKeys key level = padStr (maxKeyLength allKeys) (formatKey key level)

    maxKeyLength allKeys = maxLength
                         $ map (\k@(key, level) -> formatKey key level) allKeys

    ppDesc allDesc desc   = padStr (maxDescLength allDesc) desc
    maxDescLength allDesc = maxLength allDesc

-- stringify a keymap
unkeyify :: (KeyMask, KeySym)
         -> String

unkeyify (m,s) = let dp "" = ""
                     dp p  = p ++ " + "
                 in dp (vmask m) ++ XM.keysymToString s

vmask :: KeyMask
      -> String

vmask msk = List.intercalate " + "
          $ reverse
          $ fst
          $ foldr vmask' ([], msk) masks
  where
    masks = map (\m -> (m, show m)) [0..toEnum (bitSize msk - 1)] ++
            [ (lockMask,    "lock")
            , (controlMask, "ctrl")
            , (shiftMask,   "shift")
            , (mod5Mask,    "mod5")
            , (mod4Mask,    "meta")
            , (mod3Mask,    "scrolllock")
            , (mod2Mask,    "numlock")
            , (mod1Mask,    "alt")
            ]
    vmask'   _    a@( _, 0)                = a
    vmask' (m, s)   (ss, v) | v .&. m == m = (s:ss, v .&. complement m)
    vmask'   _         r                   = r

-- ───────────────────────────────────────────── misc - utils - tuple •3.05• ──┤

mapT :: (a -> b)
     -> (a, a)
     -> (b, b)

mapT f (a1, a2) = (f a1, f a2)

-- ────────────────────────────────────────────── misc - utils - list •3.06• ──┤

maxLength :: Foldable t
          => [t a]
          -> Int

maxLength a = maximum $ map length a

-- ──────────────────────────────────────────── misc - utils - string •3.07• ──┤

padStr :: Int
       -> String
       -> String

padStr n s
  | length s < n = s ++ replicate (n - length s) ' '
  | otherwise    = s

-- ────────────────────────────────────────────────── misc - xmessage •3.08• ──┤

xmessage :: String
         -> String

xmessage msg = "echo \"" ++ msg ++ "\" | xmessage -file -"

-- ────────────────────────────────────────────────────────────────────────────┘


-- vim: set filetype=eruby.haskell :
